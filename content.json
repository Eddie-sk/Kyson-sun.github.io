{"meta":{"title":"Kyson's blog","subtitle":null,"description":null,"author":"Kyson","url":"http://Kyson-sun.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-09-12T03:50:08.000Z","updated":"2019-09-12T03:58:33.928Z","comments":true,"path":"categories/index.html","permalink":"http://Kyson-sun.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-12T05:40:33.000Z","updated":"2019-09-12T05:43:39.269Z","comments":true,"path":"tags/index.html","permalink":"http://Kyson-sun.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"织语 iOS Hybird 框架","slug":"ccwork iOS Hybird框架","date":"2018-03-19T16:00:00.000Z","updated":"2019-09-17T03:15:51.669Z","comments":true,"path":"2018/03/20/ccwork iOS Hybird框架/","link":"","permalink":"http://Kyson-sun.github.io/2018/03/20/ccwork iOS Hybird框架/","excerpt":"","text":"前言Hybird 作为一种混合开发模式，依赖 Native 端的 Web 容器（UIWebView / WKWebView），上层使用 H5、JS 做业务开发。这种开发模式，非常有利于办公协同APP的开放平台搭建，由 Native 端提供API，供第三方使用开发、快速迭代。 Hybird App 框架一个完整的 Hybrid APP 框架主要包括 Manager、WebView 、Bridge、Cache 等模块。整个框架设计理念是组合，而不是继承，因此框架设计的不是一个 XXWebView / XXWebViewController 基类，使用者不需要在业务代码中继承 WebView 。框架设计的是一个 Manager 对象，使用者只需要跟自己业务中的任意一种 WebView 进行绑定，就可以拥有 Hybrid 的能力。 Manager 作为核心， 负责处理 Hybird 业务，校验和注册API WebView 作为容器，负责展示前端页面，响应前端交互 Bridge 作为桥梁，负责 Native 和 JS 之间通信交互 Cache 作为缓存，负责缓存资源文件等 WebView 容器iOS8 以后苹果推出了一套新的 WKWebView，对于 UIWebView 和 WKWebView 的区别，可以参考 教你使用 WKWebView 的正确姿势，本框架暂时使用 WKWebView 作为容器，针对 WKWebView 的区别，本框架做了一下解决方案： Cookie 问题前端抛弃对 Cookie 的依赖，改为使用 H5 的 Storage 能力。另 Native 提供存读接口，以备前端使用存储功能。 NSURLProtocol 支持WKWebView 包含一个 browsingContextController 属性对象，该对象提供了 registerSchemeForCustomProtocol 和 unregisterSchemeForCustomProtocol 两个方法，能通过注册 scheme 来代理同类请求，符合注册 scheme 类型的请求会走 NSURLProtocol 协议。但是这种方案存在两个严重缺陷：post 请求 body 数据被清空；对 ATS 支持不足。 跨域访问iOS9 以后，可以通过 KVC 设置 WKPreferences 的 allowFileAccessFromFileURLs 和 allowUniversalAccessFromFileURLs 属性，来打开跨域访问。但是 iOS8 暂不支持。 跨域白屏的问题在 WKWebView 白屏的时候，webView.title 会被置空，因此，可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。 缓存问题针对单个资源文件，可以对该资源地址加时间戳避开缓存。针对全局资源文件，需要手动清理缓存，iOS9 以后，系统提供了缓存管理接口 WKWebsiteDataStore。而 iOS8，只能通过手动删除文件来解决了，WKWebView 的缓存数据会存储在 ~/Library/Caches/BundleID/WebKit/ 目录下，可通过删除该目录来实现清理缓存。 Bridge由于容器选择是 WKWebView，所以 JS 调用 Native 端有两种方式 URL拦截 和 messageHandler 。本框架采用 messageHandler + evaluatingJavaScript 的方式进行通信交互。 JS -&gt; Native 交互Native 注入1234//配置对象注入[self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;nativeObject&quot;];//移除对象注入[self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;nativeObject&quot;]; JS 调用12345678//准备要传给native的数据，包括指令，数据，回调等var data = &#123; action:&apos;xxxx&apos;, params:&apos;xxxx&apos;, callback:&apos;xxxx&apos;,&#125;;//传递给客户端window.webkit.messageHandlers.nativeObject.postMessage(data); Native 接收当 JS 开始调用后，会调用到指定的 WKScriptMessageHandler 代理对象 12345678-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; //1 取出 name 是否与注入 name 匹配 if (message.name isEqualToString:@&quot;nativeObject&quot;) &#123; //2 取出对象，做后续操作 NSDictionary *msgBody = message.body; &#125;&#125; Native -&gt; JS对于 WKWebView ，除了evaluatingJavaScript，还有 WKUserScript 这个方式可以执行 JS 代码，他们之间是有区别的 evaluatingJavaScript 是在客户端执行这条代码的时候立刻去执行当条JS代码 WKUserScript 是预先准备好JS代码，当 WKWebView 加载 Dom 的时候，执行当条 JS 代码 很明显这个虽然是一种通信方式，但并不能随时随地进行通信，并不适合选则作为设计 Bridge 的核心方案。 注入时机并不是所有前端页面都需要用到 Native 能力，因此在需要用到 Native 能力的页面，才注入 JS 代码，为其提供 Native 能力。如果需要，使用假跳转至一个指定的 URL, 然后客户端在代理方法 webView:(WKWebView *)webViewdecidePolicyForNavigationAction:decisionHandler: 里判断 URL 是否为指定的 URL，如果是，则执行注入。 12345678910- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; NSURL *url = navigationAction.request.URL; if ([url.absoluteString isEqualToString:@&quot;指定URL&quot;]) &#123; // 执行注入 JS 代码 decisionHandler(WKNavigationActionPolicyCancel); return; &#125; decisionHandler(WKNavigationActionPolicyAllow);&#125; Bridge 框架这个 Native 和 JS 的 Bridge 交互如下： Property messageHandlers 字典，以 handlerName 作为 key，保存对应 function responseCallbacks 字典，以 callbackId 作为 key，保存响应 function function doSend: 调用另一端方法，传递 message 字典参数 responseAnotherMethod: 响应另一端的调用，接收 message 字典参数 ManagerManager 为整个 Hybrid 核心，负责 JS 方法到 Native 端的映射，可灵活扩展。利用 runtime 特性，使用得到的 className 和 functionName 反射出指定的对象，并执行指定函数。 权限验证针对打开的 WebView, 是否拥有合法使用 Hybrid 的权限需要进行验证，只有验证通过的页面，才能使用原生提供的能力。Manager 提供入口，具体验证由上层实现。 1- (void)authenticationSignatureParameter:(NSDictionary *)parameter comlete:(void (^)(NSError *error))complete; 组件协议JS 页面加载完，在使用 Native 能力之前，需要进行注册，即告知 Native 当前页面所需要使用的 API 列表。Manager 处理该流程，验证 Native 是否实现该 API，同时把 API 转换成对象，对象遵循以下协议： 1234567891011121314151617@protocol KKWebViewJSApiBaseProtocol &lt;NSObject&gt;@required/// api名字@property (nonatomic, copy) NSString *apiName;/// 是否支持js多次回调@property (nonatomic, assign) NSInteger isNeedRegistId;/// 是否为事件类型，客户端调用，类似发通知给JS@property (nonatomic, assign) NSInteger isEvent;/// api接口参数数据@property (nonatomic, strong) NSDictionary *paramData;/// api接口响应回调@property (nonatomic, copy) WVJBResponseCallback responseCallback;@property (nonatomic, weak) KKWebViewJavaScriptManager *jsManager;@end; 反射函数Manager 把 API 转换成对象时，利用 Objective-C 的 runtime 反射机制： 1234567891011121314151617Class cls = NSClassFromString(className);if ([cls conformsToProtocol:@protocol(KKWebViewJSApiBaseProtocol)]) &#123; id&lt;KKWebViewJSApiBaseProtocol&gt; obj = [[cls alloc] init]; if ([obj respondsToSelector:NSSelectorFromString(functionName)]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [obj performSelector:NSSelectorFromString(functionName)];#pragma clang diagnostic pop return obj; &#125; else &#123; NSLog(@&quot;function is not found&quot;); return nil; &#125;&#125; else &#123; NSLog(@&quot;clss is not found&quot;); return nil;&#125; 参考文章从零收拾一个hybrid框架 JSBridge 的原理 WKWebView 那些坑 浅谈 Hybrid 技术的设计与实现58 同城 iOS 客户端 Hybrid 框架探索 自己动手打造基于 WKWebView 的混合开发框架","categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://Kyson-sun.github.io/categories/Hybird/"}],"tags":[{"name":"Hybird","slug":"Hybird","permalink":"http://Kyson-sun.github.io/tags/Hybird/"}]},{"title":"织语 IM 消息 框架设计","slug":"织语-IM-消息-框架设计","date":"2018-03-02T03:05:48.000Z","updated":"2019-09-17T03:14:38.116Z","comments":true,"path":"2018/03/02/织语-IM-消息-框架设计/","link":"","permalink":"http://Kyson-sun.github.io/2018/03/02/织语-IM-消息-框架设计/","excerpt":"","text":"前言如何从零开始设计消息界面，应该考虑哪些问题。架构的选型，消息页面承载了各种各样的业务，不应该所有业务都集中在 VC，随着业务的增长，VC 只会越来越臃肿，合适的架构，不仅便于拓展，也有利于消息页面的长足发展。 消息页面业务列表： 消息接收，发送，更新 消息的上下加载 不同消息 cell 展示 cell 长按 menu 事件 cell 内点击事件 输入框事件 不同消息页的展示 消息界面框架消息界面 MessageViewController 继承 UIViewController，由 UITableView(界面)，MessageConfig (消息配置)，MessageInteractor (逻辑控制器) 作为基本构成。 消息配置类APP 内会存在不同消息界面展示需求，如单聊，群聊，公众号，历史消息浏览等，框架抽象出一些常用的配置接口以便于业务方修改界面。配置类不是必须实现的，如果不实现，则使用默认配置。 配置类具体注入步骤为: 继承消息类 MessageViewController 。 创建配置类，实现协议 MessageConfig。 在继承的消息类中，重写父类接口 - (id)messageConfig 方法，返回创建的配置类。 逻辑实现类由于消息界面比较复杂，框架抽象出了逻辑实现类接口 MessageInteractorMessageInteractor 由 数据逻辑 MessageDataSource 和 排版逻辑 MessageLayout 两部分接口组成。 数据逻辑 MessageDataSource 主要用于消息的数据的增删改查，作为界面的数据源，并缓存一些计算的中间数据，避免重复运算，提高性能。 排版逻辑 MessageLayout 主要用于消息的排版操作， MessageLayout 不关心具体数据，只根据上层控制，对界面排版做出调整。 消息展示逻辑消息普通展示 消息通过 srvMsgId 和 clientOrder 两者共同排序。srvMsgId，为服务器生成的消息有序 Id。clientOrder 为本地客户端生成的有序数列。消息排序时，先根据 srvMsgId 进行排序，如果srvMsgId 一致，则在比较 clientOrder。正常情况下，发送成功的消息，即拥有唯一 srvMsgId。但客户端新建一条待发送的消息时，该消息的 srvMsgId，取至本地消息最大的 srvMsgId，同时 clientOrder 在最大消息的 clientOrder 上加一。这样子保证了本地消息排序的有序。等到新消息发送成功，服务器返回后，更新该 srvMsgId 为服务器的最新 srvMsgId，同时 clientOrder 置为0。 消息发送成功后，返回 srvMsgId 可能导致排序变化，出于性能考量，不对已展示消息重新排序，等用户下次再进入消息界面，即会展示正确的消息排序。 上拉拉取数据逻辑，异步加载一屏本地数据，如果本地数据不足一屏，则再异步拉取服务器数据。凑满一屏数据后，返回界面展示。当服务器返回无更多数据后，上拉拉取UI控件隐藏 一直加载老数据，使得数据源消息数大于设定的最大值时，则清楚数据源内排序靠后的老数据，同时向下加载更多 UI 控件变更为显示 上拉拉取时，菊花开始转，tableView 处于滑动状态，offset 一直在变。应该等 tableVew 停止滑动后，再开始进行 tableView 的 reloadData 操作，重设 offset。所以调用 performSelectorOnMainThread:withObject:waitUntilDone:modes: 执行 reloadData 操作，该方法能在 tableView 停止滑动，即 runloop 空闲后执行操作。 下拉加载数据逻辑，仅当向下加载更多UI控件显示时，触发。逻辑同上拉拉取逻辑一致。当服务器返回无更多数据后，向下加载更多UI控件隐藏。 点击输入框时，界面直接跳转至最新数据展示。以向下加载更多UI控件是否隐藏作为标志位，如果隐藏，说明当前数据即为最新数据，界面直接跳转至末尾。如果显示，则当前数据不是最新数据，则清空界面数据，异步拉取最新一屏本地数据展示，同时异步拉取服务器最新数据，待服务器数据返回后，再和本地数据合并，展示在界面。 接收新消息时，后台线程计算Layout，计算完毕后，放入 pendingMessage 数组，在合适的时机，如 tableView 无滑动时，切主线程，一个一个的加入数据源，更新 tableView。如果数据源消息大于设定最大值，则清理数据源内排序靠前的老数据 正常进入消息界面 同步加载一屏本地数据，同时异步拉取服务器最新数据 服务器最新数据返回，如果与本地一致，不做处理。如果数据量大于一屏，清楚之前加载数据，替换数据为最新一屏数据。如果数据量小于一屏，则在展示的本地数据后，直接添加最新数据 向下加载更多UI控件隐藏 指定跳转某一条消息 以该条消息为基准，异步上下加载一屏本地数据，如果本地数据不足一屏，则再异步拉取服务器数据。凑满一屏数据后，返回界面展示 向下加载更多UI控件不隐藏","categories":[],"tags":[{"name":"消息框架","slug":"消息框架","permalink":"http://Kyson-sun.github.io/tags/消息框架/"}]}]}