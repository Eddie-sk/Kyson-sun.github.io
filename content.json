{"meta":{"title":"Kyson's blog","subtitle":null,"description":null,"author":"Kyson","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2019-09-12T05:40:33.000Z","updated":"2019-09-12T05:43:39.269Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-09-12T03:50:08.000Z","updated":"2019-09-12T03:58:33.928Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"织语 iOS Hybird 框架","slug":"ccwork iOS Hybird框架","date":"2018-03-19T16:00:00.000Z","updated":"2019-09-12T07:36:09.433Z","comments":true,"path":"2018/03/20/ccwork iOS Hybird框架/","link":"","permalink":"http://yoursite.com/2018/03/20/ccwork iOS Hybird框架/","excerpt":"","text":"前言Hybird 作为一种混合开发模式，依赖 Native 端的 Web 容器（UIWebView / WKWebView），上层使用 H5、JS 做业务开发。这种开发模式，非常有利于办公协同APP的开放平台搭建，由 Native 端提供API，供第三方使用开发、快速迭代。 Hybird App 框架一个完整的 Hybrid APP 框架主要包括 Manager、WebView 、Bridge、Cache 等模块。整个框架设计理念是组合，而不是继承，因此框架设计的不是一个 XXWebView / XXWebViewController 基类，使用者不需要在业务代码中继承 WebView 。框架设计的是一个 Manager 对象，使用者只需要跟自己业务中的任意一种 WebView 进行绑定，就可以拥有 Hybrid 的能力。 Manager 作为核心， 负责处理 Hybird 业务，校验和注册API WebView 作为容器，负责展示前端页面，响应前端交互 Bridge 作为桥梁，负责 Native 和 JS 之间通信交互 Cache 作为缓存，负责缓存资源文件等 WebView 容器iOS8 以后苹果推出了一套新的 WKWebView，对于 UIWebView 和 WKWebView 的区别，可以参考 教你使用 WKWebView 的正确姿势，本框架暂时使用 WKWebView 作为容器，针对 WKWebView 的区别，本框架做了一下解决方案： Cookie 问题前端抛弃对 Cookie 的依赖，改为使用 H5 的 Storage 能力。另 Native 提供存读接口，以备前端使用存储功能。 NSURLProtocol 支持WKWebView 包含一个 browsingContextController 属性对象，该对象提供了 registerSchemeForCustomProtocol 和 unregisterSchemeForCustomProtocol 两个方法，能通过注册 scheme 来代理同类请求，符合注册 scheme 类型的请求会走 NSURLProtocol 协议。但是这种方案存在两个严重缺陷：post 请求 body 数据被清空；对 ATS 支持不足。 跨域访问iOS9 以后，可以通过 KVC 设置 WKPreferences 的 allowFileAccessFromFileURLs 和 allowUniversalAccessFromFileURLs 属性，来打开跨域访问。但是 iOS8 暂不支持。 跨域白屏的问题在 WKWebView 白屏的时候，webView.title 会被置空，因此，可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。 缓存问题针对单个资源文件，可以对该资源地址加时间戳避开缓存。针对全局资源文件，需要手动清理缓存，iOS9 以后，系统提供了缓存管理接口 WKWebsiteDataStore。而 iOS8，只能通过手动删除文件来解决了，WKWebView 的缓存数据会存储在 ~/Library/Caches/BundleID/WebKit/ 目录下，可通过删除该目录来实现清理缓存。 Bridge由于容器选择是 WKWebView，所以 JS 调用 Native 端有两种方式 URL拦截 和 messageHandler 。本框架采用 messageHandler + evaluatingJavaScript 的方式进行通信交互。 JS -&gt; Native 交互Native 注入1234//配置对象注入[self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;nativeObject&quot;];//移除对象注入[self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;nativeObject&quot;]; JS 调用12345678//准备要传给native的数据，包括指令，数据，回调等var data = &#123; action:&apos;xxxx&apos;, params:&apos;xxxx&apos;, callback:&apos;xxxx&apos;,&#125;;//传递给客户端window.webkit.messageHandlers.nativeObject.postMessage(data); Native 接收当 JS 开始调用后，会调用到指定的 WKScriptMessageHandler 代理对象 12345678-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; //1 取出 name 是否与注入 name 匹配 if (message.name isEqualToString:@&quot;nativeObject&quot;) &#123; //2 取出对象，做后续操作 NSDictionary *msgBody = message.body; &#125;&#125; Native -&gt; JS对于 WKWebView ，除了evaluatingJavaScript，还有 WKUserScript 这个方式可以执行 JS 代码，他们之间是有区别的 evaluatingJavaScript 是在客户端执行这条代码的时候立刻去执行当条JS代码 WKUserScript 是预先准备好JS代码，当 WKWebView 加载 Dom 的时候，执行当条 JS 代码 很明显这个虽然是一种通信方式，但并不能随时随地进行通信，并不适合选则作为设计 Bridge 的核心方案。 注入时机并不是所有前端页面都需要用到 Native 能力，因此在需要用到 Native 能力的页面，才注入 JS 代码，为其提供 Native 能力。如果需要，使用假跳转至一个指定的 URL, 然后客户端在代理方法 webView:(WKWebView *)webViewdecidePolicyForNavigationAction:decisionHandler: 里判断 URL 是否为指定的 URL，如果是，则执行注入。 12345678910- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; NSURL *url = navigationAction.request.URL; if ([url.absoluteString isEqualToString:@&quot;指定URL&quot;]) &#123; // 执行注入 JS 代码 decisionHandler(WKNavigationActionPolicyCancel); return; &#125; decisionHandler(WKNavigationActionPolicyAllow);&#125; Bridge 框架这个 Native 和 JS 的 Bridge 交互如下： Property messageHandlers 字典，以 handlerName 作为 key，保存对应 function responseCallbacks 字典，以 callbackId 作为 key，保存响应 function function doSend: 调用另一端方法，传递 message 字典参数 responseAnotherMethod: 响应另一端的调用，接收 message 字典参数 ManagerManager 为整个 Hybrid 核心，负责 JS 方法到 Native 端的映射，可灵活扩展。利用 runtime 特性，使用得到的 className 和 functionName 反射出指定的对象，并执行指定函数。 权限验证针对打开的 WebView, 是否拥有合法使用 Hybrid 的权限需要进行验证，只有验证通过的页面，才能使用原生提供的能力。Manager 提供入口，具体验证由上层实现。 1- (void)authenticationSignatureParameter:(NSDictionary *)parameter comlete:(void (^)(NSError *error))complete; 组件协议JS 页面加载完，在使用 Native 能力之前，需要进行注册，即告知 Native 当前页面所需要使用的 API 列表。Manager 处理该流程，验证 Native 是否实现该 API，同时把 API 转换成对象，对象遵循以下协议： 1234567891011121314151617@protocol KKWebViewJSApiBaseProtocol &lt;NSObject&gt;@required/// api名字@property (nonatomic, copy) NSString *apiName;/// 是否支持js多次回调@property (nonatomic, assign) NSInteger isNeedRegistId;/// 是否为事件类型，客户端调用，类似发通知给JS@property (nonatomic, assign) NSInteger isEvent;/// api接口参数数据@property (nonatomic, strong) NSDictionary *paramData;/// api接口响应回调@property (nonatomic, copy) WVJBResponseCallback responseCallback;@property (nonatomic, weak) KKWebViewJavaScriptManager *jsManager;@end; 反射函数Manager 把 API 转换成对象时，利用 Objective-C 的 runtime 反射机制： 1234567891011121314151617Class cls = NSClassFromString(className);if ([cls conformsToProtocol:@protocol(KKWebViewJSApiBaseProtocol)]) &#123; id&lt;KKWebViewJSApiBaseProtocol&gt; obj = [[cls alloc] init]; if ([obj respondsToSelector:NSSelectorFromString(functionName)]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [obj performSelector:NSSelectorFromString(functionName)];#pragma clang diagnostic pop return obj; &#125; else &#123; NSLog(@&quot;function is not found&quot;); return nil; &#125;&#125; else &#123; NSLog(@&quot;clss is not found&quot;); return nil;&#125; 参考文章从零收拾一个hybrid框架 JSBridge 的原理 WKWebView 那些坑 浅谈 Hybrid 技术的设计与实现58 同城 iOS 客户端 Hybrid 框架探索 自己动手打造基于 WKWebView 的混合开发框架","categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://yoursite.com/categories/Hybird/"}],"tags":[]},{"title":"hexo使用小技能","slug":"hexo使用小技能","date":"2018-03-12T06:17:33.000Z","updated":"2019-09-12T06:49:35.381Z","comments":true,"path":"2018/03/12/hexo使用小技能/","link":"","permalink":"http://yoursite.com/2018/03/12/hexo使用小技能/","excerpt":"","text":"插入本地图片Hexo 插入本地图片的路径让人十分头疼，因为生成 public 的 html 时，每一篇都是在年月日做文件夹目录的文件下，例如 /blog/public/2018/03/12/Hexo使用小技巧而主页的 html 文件又不在这个文件下，与博文的目录不同 /blog/public这与在 _posts 目录下边写博客的 md 文件目录完全不同。 而 hexo 官方文档为我们提供了一种插入图片的方法，但是这与我们平常编写 Markdown 文件的语法差别很大。 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 那么 Hexo 有没有能像 Markdown 的语法一样插入本地图片呢，Hexo 为我们提供了一个插件，如下。 Hexo 配置文件在设置文件中加入选项配置： post_asset_folder: true这个配置实际上是在我们生成文件 ( hexo new )的时候，会在 /source/_posts 文件夹下创建一个文件名相同的文件夹，可以在此文件夹下放入图片，或者附件。 安装 hexo-asset-image 插件npm install https://github.com/CodeFalling/hexo-asset-image --save插件安装完成后，实际上是存放在下面这个文件夹中 /node_modules/hexo-asset-image","categories":[],"tags":[{"name":"hexo使用","slug":"hexo使用","permalink":"http://yoursite.com/tags/hexo使用/"}]}]}