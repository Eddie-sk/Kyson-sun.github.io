{"meta":{"title":"Kyson's blog","subtitle":null,"description":null,"author":"Kyson","url":"http://Kyson-sun.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-09-12T03:50:08.000Z","updated":"2019-09-12T03:58:33.928Z","comments":true,"path":"categories/index.html","permalink":"http://Kyson-sun.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-12T05:40:33.000Z","updated":"2019-09-12T05:43:39.269Z","comments":true,"path":"tags/index.html","permalink":"http://Kyson-sun.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ReactiveCocoa","slug":"ReactiveCocoa/ReactiveCocoa","date":"2019-09-19T07:47:02.000Z","updated":"2019-09-19T09:26:45.587Z","comments":true,"path":"2019/09/19/ReactiveCocoa/ReactiveCocoa/","link":"","permalink":"http://Kyson-sun.github.io/2019/09/19/ReactiveCocoa/ReactiveCocoa/","excerpt":"","text":"背景ReactiveCocoa (简称 RAC )，是由 GitHub 团队开发的一款基于 Cocoa 的 FRP 框架。FRP 就是 Functional Reactive Programming (函数响应式编程)，优点是用随时间改变的函数表示用户输入，这样就不需要可变状态了。","categories":[],"tags":[{"name":"ReactiveCocoa","slug":"ReactiveCocoa","permalink":"http://Kyson-sun.github.io/tags/ReactiveCocoa/"}]},{"title":"织语 iOS Hybird 框架","slug":"ccwork iOS Hybird框架","date":"2018-03-19T16:00:00.000Z","updated":"2019-09-17T03:15:51.669Z","comments":true,"path":"2018/03/20/ccwork iOS Hybird框架/","link":"","permalink":"http://Kyson-sun.github.io/2018/03/20/ccwork iOS Hybird框架/","excerpt":"","text":"前言Hybird 作为一种混合开发模式，依赖 Native 端的 Web 容器（UIWebView / WKWebView），上层使用 H5、JS 做业务开发。这种开发模式，非常有利于办公协同APP的开放平台搭建，由 Native 端提供API，供第三方使用开发、快速迭代。 Hybird App 框架一个完整的 Hybrid APP 框架主要包括 Manager、WebView 、Bridge、Cache 等模块。整个框架设计理念是组合，而不是继承，因此框架设计的不是一个 XXWebView / XXWebViewController 基类，使用者不需要在业务代码中继承 WebView 。框架设计的是一个 Manager 对象，使用者只需要跟自己业务中的任意一种 WebView 进行绑定，就可以拥有 Hybrid 的能力。 Manager 作为核心， 负责处理 Hybird 业务，校验和注册API WebView 作为容器，负责展示前端页面，响应前端交互 Bridge 作为桥梁，负责 Native 和 JS 之间通信交互 Cache 作为缓存，负责缓存资源文件等 WebView 容器iOS8 以后苹果推出了一套新的 WKWebView，对于 UIWebView 和 WKWebView 的区别，可以参考 教你使用 WKWebView 的正确姿势，本框架暂时使用 WKWebView 作为容器，针对 WKWebView 的区别，本框架做了一下解决方案： Cookie 问题前端抛弃对 Cookie 的依赖，改为使用 H5 的 Storage 能力。另 Native 提供存读接口，以备前端使用存储功能。 NSURLProtocol 支持WKWebView 包含一个 browsingContextController 属性对象，该对象提供了 registerSchemeForCustomProtocol 和 unregisterSchemeForCustomProtocol 两个方法，能通过注册 scheme 来代理同类请求，符合注册 scheme 类型的请求会走 NSURLProtocol 协议。但是这种方案存在两个严重缺陷：post 请求 body 数据被清空；对 ATS 支持不足。 跨域访问iOS9 以后，可以通过 KVC 设置 WKPreferences 的 allowFileAccessFromFileURLs 和 allowUniversalAccessFromFileURLs 属性，来打开跨域访问。但是 iOS8 暂不支持。 跨域白屏的问题在 WKWebView 白屏的时候，webView.title 会被置空，因此，可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。 缓存问题针对单个资源文件，可以对该资源地址加时间戳避开缓存。针对全局资源文件，需要手动清理缓存，iOS9 以后，系统提供了缓存管理接口 WKWebsiteDataStore。而 iOS8，只能通过手动删除文件来解决了，WKWebView 的缓存数据会存储在 ~/Library/Caches/BundleID/WebKit/ 目录下，可通过删除该目录来实现清理缓存。 Bridge由于容器选择是 WKWebView，所以 JS 调用 Native 端有两种方式 URL拦截 和 messageHandler 。本框架采用 messageHandler + evaluatingJavaScript 的方式进行通信交互。 JS -&gt; Native 交互Native 注入1234//配置对象注入[self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;nativeObject&quot;];//移除对象注入[self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;nativeObject&quot;]; JS 调用12345678//准备要传给native的数据，包括指令，数据，回调等var data = &#123; action:&apos;xxxx&apos;, params:&apos;xxxx&apos;, callback:&apos;xxxx&apos;,&#125;;//传递给客户端window.webkit.messageHandlers.nativeObject.postMessage(data); Native 接收当 JS 开始调用后，会调用到指定的 WKScriptMessageHandler 代理对象 12345678-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; //1 取出 name 是否与注入 name 匹配 if (message.name isEqualToString:@&quot;nativeObject&quot;) &#123; //2 取出对象，做后续操作 NSDictionary *msgBody = message.body; &#125;&#125; Native -&gt; JS对于 WKWebView ，除了evaluatingJavaScript，还有 WKUserScript 这个方式可以执行 JS 代码，他们之间是有区别的 evaluatingJavaScript 是在客户端执行这条代码的时候立刻去执行当条JS代码 WKUserScript 是预先准备好JS代码，当 WKWebView 加载 Dom 的时候，执行当条 JS 代码 很明显这个虽然是一种通信方式，但并不能随时随地进行通信，并不适合选则作为设计 Bridge 的核心方案。 注入时机并不是所有前端页面都需要用到 Native 能力，因此在需要用到 Native 能力的页面，才注入 JS 代码，为其提供 Native 能力。如果需要，使用假跳转至一个指定的 URL, 然后客户端在代理方法 webView:(WKWebView *)webViewdecidePolicyForNavigationAction:decisionHandler: 里判断 URL 是否为指定的 URL，如果是，则执行注入。 12345678910- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; NSURL *url = navigationAction.request.URL; if ([url.absoluteString isEqualToString:@&quot;指定URL&quot;]) &#123; // 执行注入 JS 代码 decisionHandler(WKNavigationActionPolicyCancel); return; &#125; decisionHandler(WKNavigationActionPolicyAllow);&#125; Bridge 框架这个 Native 和 JS 的 Bridge 交互如下： Property messageHandlers 字典，以 handlerName 作为 key，保存对应 function responseCallbacks 字典，以 callbackId 作为 key，保存响应 function function doSend: 调用另一端方法，传递 message 字典参数 responseAnotherMethod: 响应另一端的调用，接收 message 字典参数 ManagerManager 为整个 Hybrid 核心，负责 JS 方法到 Native 端的映射，可灵活扩展。利用 runtime 特性，使用得到的 className 和 functionName 反射出指定的对象，并执行指定函数。 权限验证针对打开的 WebView, 是否拥有合法使用 Hybrid 的权限需要进行验证，只有验证通过的页面，才能使用原生提供的能力。Manager 提供入口，具体验证由上层实现。 1- (void)authenticationSignatureParameter:(NSDictionary *)parameter comlete:(void (^)(NSError *error))complete; 组件协议JS 页面加载完，在使用 Native 能力之前，需要进行注册，即告知 Native 当前页面所需要使用的 API 列表。Manager 处理该流程，验证 Native 是否实现该 API，同时把 API 转换成对象，对象遵循以下协议： 1234567891011121314151617@protocol KKWebViewJSApiBaseProtocol &lt;NSObject&gt;@required/// api名字@property (nonatomic, copy) NSString *apiName;/// 是否支持js多次回调@property (nonatomic, assign) NSInteger isNeedRegistId;/// 是否为事件类型，客户端调用，类似发通知给JS@property (nonatomic, assign) NSInteger isEvent;/// api接口参数数据@property (nonatomic, strong) NSDictionary *paramData;/// api接口响应回调@property (nonatomic, copy) WVJBResponseCallback responseCallback;@property (nonatomic, weak) KKWebViewJavaScriptManager *jsManager;@end; 反射函数Manager 把 API 转换成对象时，利用 Objective-C 的 runtime 反射机制： 1234567891011121314151617Class cls = NSClassFromString(className);if ([cls conformsToProtocol:@protocol(KKWebViewJSApiBaseProtocol)]) &#123; id&lt;KKWebViewJSApiBaseProtocol&gt; obj = [[cls alloc] init]; if ([obj respondsToSelector:NSSelectorFromString(functionName)]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [obj performSelector:NSSelectorFromString(functionName)];#pragma clang diagnostic pop return obj; &#125; else &#123; NSLog(@&quot;function is not found&quot;); return nil; &#125;&#125; else &#123; NSLog(@&quot;clss is not found&quot;); return nil;&#125; 参考文章从零收拾一个hybrid框架 JSBridge 的原理 WKWebView 那些坑 浅谈 Hybrid 技术的设计与实现58 同城 iOS 客户端 Hybrid 框架探索 自己动手打造基于 WKWebView 的混合开发框架","categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://Kyson-sun.github.io/categories/Hybird/"}],"tags":[{"name":"Hybird","slug":"Hybird","permalink":"http://Kyson-sun.github.io/tags/Hybird/"}]},{"title":"织语 IM 消息 框架设计","slug":"织语-IM-消息-框架设计","date":"2018-03-02T03:05:48.000Z","updated":"2019-09-17T03:14:38.116Z","comments":true,"path":"2018/03/02/织语-IM-消息-框架设计/","link":"","permalink":"http://Kyson-sun.github.io/2018/03/02/织语-IM-消息-框架设计/","excerpt":"","text":"前言如何从零开始设计消息界面，应该考虑哪些问题。架构的选型，消息页面承载了各种各样的业务，不应该所有业务都集中在 VC，随着业务的增长，VC 只会越来越臃肿，合适的架构，不仅便于拓展，也有利于消息页面的长足发展。 消息页面业务列表： 消息接收，发送，更新 消息的上下加载 不同消息 cell 展示 cell 长按 menu 事件 cell 内点击事件 输入框事件 不同消息页的展示 消息界面框架消息界面 MessageViewController 继承 UIViewController，由 UITableView(界面)，MessageConfig (消息配置)，MessageInteractor (逻辑控制器) 作为基本构成。 消息配置类APP 内会存在不同消息界面展示需求，如单聊，群聊，公众号，历史消息浏览等，框架抽象出一些常用的配置接口以便于业务方修改界面。配置类不是必须实现的，如果不实现，则使用默认配置。 配置类具体注入步骤为: 继承消息类 MessageViewController 。 创建配置类，实现协议 MessageConfig。 在继承的消息类中，重写父类接口 - (id)messageConfig 方法，返回创建的配置类。 逻辑实现类由于消息界面比较复杂，框架抽象出了逻辑实现类接口 MessageInteractorMessageInteractor 由 数据逻辑 MessageDataSource 和 排版逻辑 MessageLayout 两部分接口组成。 数据逻辑 MessageDataSource 主要用于消息的数据的增删改查，作为界面的数据源，并缓存一些计算的中间数据，避免重复运算，提高性能。 排版逻辑 MessageLayout 主要用于消息的排版操作， MessageLayout 不关心具体数据，只根据上层控制，对界面排版做出调整。 消息展示逻辑消息普通展示 消息通过 srvMsgId 和 clientOrder 两者共同排序。srvMsgId，为服务器生成的消息有序 Id。clientOrder 为本地客户端生成的有序数列。消息排序时，先根据 srvMsgId 进行排序，如果srvMsgId 一致，则在比较 clientOrder。正常情况下，发送成功的消息，即拥有唯一 srvMsgId。但客户端新建一条待发送的消息时，该消息的 srvMsgId，取至本地消息最大的 srvMsgId，同时 clientOrder 在最大消息的 clientOrder 上加一。这样子保证了本地消息排序的有序。等到新消息发送成功，服务器返回后，更新该 srvMsgId 为服务器的最新 srvMsgId，同时 clientOrder 置为0。 消息发送成功后，返回 srvMsgId 可能导致排序变化，出于性能考量，不对已展示消息重新排序，等用户下次再进入消息界面，即会展示正确的消息排序。 上拉拉取数据逻辑，异步加载一屏本地数据，如果本地数据不足一屏，则再异步拉取服务器数据。凑满一屏数据后，返回界面展示。当服务器返回无更多数据后，上拉拉取UI控件隐藏 一直加载老数据，使得数据源消息数大于设定的最大值时，则清楚数据源内排序靠后的老数据，同时向下加载更多 UI 控件变更为显示 上拉拉取时，菊花开始转，tableView 处于滑动状态，offset 一直在变。应该等 tableVew 停止滑动后，再开始进行 tableView 的 reloadData 操作，重设 offset。所以调用 performSelectorOnMainThread:withObject:waitUntilDone:modes: 执行 reloadData 操作，该方法能在 tableView 停止滑动，即 runloop 空闲后执行操作。 下拉加载数据逻辑，仅当向下加载更多UI控件显示时，触发。逻辑同上拉拉取逻辑一致。当服务器返回无更多数据后，向下加载更多UI控件隐藏。 点击输入框时，界面直接跳转至最新数据展示。以向下加载更多UI控件是否隐藏作为标志位，如果隐藏，说明当前数据即为最新数据，界面直接跳转至末尾。如果显示，则当前数据不是最新数据，则清空界面数据，异步拉取最新一屏本地数据展示，同时异步拉取服务器最新数据，待服务器数据返回后，再和本地数据合并，展示在界面。 接收新消息时，后台线程计算Layout，计算完毕后，放入 pendingMessage 数组，在合适的时机，如 tableView 无滑动时，切主线程，一个一个的加入数据源，更新 tableView。如果数据源消息大于设定最大值，则清理数据源内排序靠前的老数据 正常进入消息界面 同步加载一屏本地数据，同时异步拉取服务器最新数据 服务器最新数据返回，如果与本地一致，不做处理。如果数据量大于一屏，清楚之前加载数据，替换数据为最新一屏数据。如果数据量小于一屏，则在展示的本地数据后，直接添加最新数据 向下加载更多UI控件隐藏 指定跳转某一条消息 以该条消息为基准，异步上下加载一屏本地数据，如果本地数据不足一屏，则再异步拉取服务器数据。凑满一屏数据后，返回界面展示 向下加载更多UI控件不隐藏","categories":[],"tags":[{"name":"消息框架","slug":"消息框架","permalink":"http://Kyson-sun.github.io/tags/消息框架/"}]},{"title":"Category 方法的调用","slug":"Category-方法的调用","date":"2017-08-27T07:57:03.000Z","updated":"2019-09-30T06:14:26.778Z","comments":true,"path":"2017/08/27/Category-方法的调用/","link":"","permalink":"http://Kyson-sun.github.io/2017/08/27/Category-方法的调用/","excerpt":"","text":"简介Category 是 Objective-C 2.0之后添加的，Category 的主要作用是为已经存在的类添加方法。另外，Apple 还推荐了 Category 的另外两个使用场景。 可以把类的实现分开在几个不同的文件里。这样可以减少单个文件的体积，可以把不同的功能组织到不同的文件里，可以多个开发者维护一个类，可以按需加载想要的 Category 声明私有方法 另外我们也可以使用 Category 实现一些意想不到的功能 模拟多继承 公开 Framework 的私有方法 Category 和 Extension extension 在编译期决议，他就是类的一部分，在编译期和头文件里的 @interface 以及实现文件里的 @impletment 一起形成一个完整的类，它伴随类的产生和消亡。 extension 一般来隐藏类的私有信息，但是必须要有类的源码才能为一个类添加extension，所以无法为系统的类添加extension category 则是运行期决议 extension 可以添加实例变量，而 category 无法添加实例变量。因为在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局 Category 源码Category 在 objc-runtime-new.h 中，Category（分类）被定义为 category_t 结构体。category_t 结构体的数据结构如下： 12345678910typedef struct category_t *Category;struct category_t &#123; const char *name; // 类名 classref_t cls; // 类，在运行时阶段通过 clasee_name（类名）对应到类对象 struct method_list_t *instanceMethods; // Category 中所有添加的对象方法列表 struct method_list_t *classMethods; // Category 中所有添加的类方法列表 struct protocol_list_t *protocols; // Category 中实现的所有协议列表 struct property_list_t *instanceProperties; // Category 中添加的所有属性&#125;; 从 Category 的结构体中可以看出，Category 可以为类添加实例方法、类方法、protocol和property，但是并不能添加成员变量 People.h 12345678910111213@interface People : NSObject- (void)run;@end@interface People (Addition)@property (nonatomic, copy) NSString *name;- (void)run;@end People.m 123456789101112131415161718192021#import &quot;People.h&quot;#import &lt;objc/runtime.h&gt;@implementation People@end@implementation People (Addition)- (void)setName:(NSString *)name &#123; objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (NSString *)name &#123; return objc_getAssociatedObject(self, @selector(name));&#125;- (void)run &#123; NSLog(@&quot;%@ can run&quot;,self.name);&#125;@end 使用clang命令查看 Category 到底是啥玩意 1clang -rewrite-objc People.m 我们会得到一个巨大无比的 cpp 文件，我们先忽略文件的大小，先看一下文件最后 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[3];&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_People_$_Addition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123; sizeof(_objc_method), 3, &#123;&#123;(struct objc_selector *)&quot;setName:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_People_Addition_setName_&#125;, &#123;(struct objc_selector *)&quot;name&quot;, &quot;@16@0:8&quot;, (void *)_I_People_Addition_name&#125;, &#123;(struct objc_selector *)&quot;run&quot;, &quot;v16@0:8&quot;, (void *)_I_People_Addition_run&#125;&#125;&#125;;static struct /*_prop_list_t*/ &#123; unsigned int entsize; // sizeof(struct _prop_t) unsigned int count_of_properties; struct _prop_t prop_list[1];&#125; _OBJC_$_PROP_LIST_People_$_Addition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123; sizeof(_prop_t), 1, &#123;&#123;&quot;name&quot;,&quot;T@\\&quot;NSString\\&quot;,C,N&quot;&#125;&#125;&#125;;extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_People;static struct _category_t _OBJC_$_CATEGORY_People_$_Addition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123; &quot;People&quot;, 0, // &amp;OBJC_CLASS_$_People, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_People_$_Addition,//生成实例方法列表 0, 0, (const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_People_$_Addition,//生成属性列表&#125;;static void OBJC_CATEGORY_SETUP_$_People_$_Addition(void ) &#123; _OBJC_$_CATEGORY_People_$_Addition.cls = &amp;OBJC_CLASS_$_People;&#125;#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123; (void *)&amp;OBJC_CATEGORY_SETUP_$_People_$_Addition,&#125;;static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123; &amp;OBJC_CLASS_$_People,&#125;;static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123; &amp;_OBJC_$_CATEGORY_People_$_Addition,&#125;; 由此我们可以看到， 编译器生成了实例方法列表 OBJC$CATEGORY_INSTANCE_METHODS_People$Addition 和属性列表 _OBJC$PROP_LIST_People$_Addition， 且实例方法列表里填充的正是我们在 category 中写的方法 run ，而属性列表中正是我们在 category 中声明的 name 属性。另外 category 的名字用来给各种列表以及后面的 category 结构体本身命名，用 static 来修饰，所以在一个编译单元里我们的 category 名不能重复，否则会编译错误 编译器生成了 category 本身 OBJC$CATEGORY_People$_Addition，并用前面生成的列表来初始化 category 本身 编译器在 DATA 段下的 objc_catlist section 里保存了一个大小为 1 的 category_t 的数组 L_OBJC_LABEL_CATEGORY_ （如果有多个 category 会生成对应长度的数组），用于运行期 category 加载 category 加载Objective-C 的运行是依赖 OC 的 runtime 的，而 OC 的 runtime 是通过 dyld 动态加载的 OC 运行时入口方法 （objc-os.mm） 123456789101112131415161718 void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); lock_init(); exception_init(); // Register for unmap first, in case some +load unmaps something _dyld_register_func_for_remove_image(&amp;unmap_image); dyld_register_image_state_change_handler(dyld_image_state_bound, 1/*batch*/, &amp;map_images); dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);&#125; category 被附加到类上面是在 map_images 的时候发生的，在 new-API 的标准下，_objc_init 里面的调用的 map_images 最终会调用 objc-runtime-new.mm 里面的 _read_images 方法，而在 _read_images 方法的结尾，有以下的代码片段： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Discover categories. for (EACH_HEADER) &#123; category_t **catlist = _getObjc2CategoryList(hi, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; class_t *cls = remapClass(cat-&gt;cls); if (!cls) &#123; // Category&apos;s target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = NULL; if (PrintConnecting) &#123; _objc_inform(&quot;CLASS: IGNORING category \\?\\?\\?(%s) %p with &quot; &quot;missing weak-linked target class&quot;, cat-&gt;name, cat); &#125; continue; &#125; // Process this category. // First, register the category with its target class. // Then, rebuild the class&apos;s method lists (etc) if // the class is realized. BOOL classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (isRealized(cls)) &#123; remethodizeClass(cls); classExists = YES; &#125; if (PrintConnecting) &#123; _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, getName(cls), cat-&gt;name, classExists ? &quot;on existing class&quot; : &quot;&quot;); &#125; &#125; if (cat-&gt;classMethods || cat-&gt;protocols /* || cat-&gt;classProperties */) &#123; addUnattachedCategoryForClass(cat, cls-&gt;isa, hi); if (isRealized(cls-&gt;isa)) &#123; remethodizeClass(cls-&gt;isa); &#125; if (PrintConnecting) &#123; _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, getName(cls), cat-&gt;name); &#125; &#125; &#125; &#125; 首先，我们拿到的 catlist 就是上节中讲到的编译器为我们准备的 category_t 数组 这段代码的意思就是： 把 category 的实例方法、协议以及属性添加到类上 把 category 的类方法和协议添加到类的 meta class 上 我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧： 在上述的代码片段里，addUnattachedCategoryForClass 只是把类和 category 做一个关联映射，而 remethodizeClass 才是真正去做添加的。 12345678910111213141516171819202122232425262728293031323334353637383940414243static void remethodizeClass(class_t *cls)&#123; category_list *cats; BOOL isMeta; rwlock_assert_writing(&amp;runtimeLock); isMeta = isMetaClass(cls); // Re-methodizing: check for more categories if ((cats = unattachedCategoriesForClass(cls))) &#123; chained_property_list *newproperties; const protocol_list_t **newprotos; if (PrintConnecting) &#123; _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;, getName(cls), isMeta ? &quot;(meta)&quot; : &quot;&quot;); &#125; // Update methods, properties, protocols BOOL vtableAffected = NO; attachCategoryMethods(cls, cats, &amp;vtableAffected); newproperties = buildPropertyList(NULL, cats, isMeta); if (newproperties) &#123; newproperties-&gt;next = cls-&gt;data()-&gt;properties; cls-&gt;data()-&gt;properties = newproperties; &#125; newprotos = buildProtocolList(cats, NULL, cls-&gt;data()-&gt;protocols); if (cls-&gt;data()-&gt;protocols &amp;&amp; cls-&gt;data()-&gt;protocols != newprotos) &#123; _free_internal(cls-&gt;data()-&gt;protocols); &#125; cls-&gt;data()-&gt;protocols = newprotos; _free_internal(cats); // Update method caches and vtables flushCaches(cls); if (vtableAffected) flushVtables(cls); &#125;&#125; 而对于添加类的实例方法而言，又会去调用 attachCategoryMethods 这个方法，我们去看下 attachCategoryMethods ： 12345678910111213141516171819202122232425262728static void attachCategoryMethods(class_t *cls, category_list *cats, BOOL *inoutVtablesAffected)&#123; if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); BOOL isMeta = isMetaClass(cls); method_list_t **mlists = (method_list_t **) _malloc_internal(cats-&gt;count * sizeof(*mlists)); // Count backwards through cats to get newest categories first int mcount = 0; int i = cats-&gt;count; BOOL fromBundle = NO; while (i--) &#123; method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= cats-&gt;list[i].fromBundle; &#125; &#125; attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected); _free_internal(mlists);&#125; attachCategoryMethods 只是把所有 category 的实例方法列表拼成了一个大的实例方法列表，然后转交给了 attachMethodLists 方法： 123456789101112131415161718192021222324for (uint32_t m = 0; (scanForCustomRR || scanForCustomAWZ) &amp;&amp; m &lt; mlist-&gt;count; m++) &#123; SEL sel = method_list_nth(mlist, m)-&gt;name; if (scanForCustomRR &amp;&amp; isRRSelector(sel)) &#123; cls-&gt;setHasCustomRR(); scanForCustomRR = false; &#125; else if (scanForCustomAWZ &amp;&amp; isAWZSelector(sel)) &#123; cls-&gt;setHasCustomAWZ(); scanForCustomAWZ = false; &#125; &#125; // Fill method list array newLists[newCount++] = mlist; . . . // Copy old methods to the method list array for (i = 0; i &lt; oldCount; i++) &#123; newLists[newCount++] = oldLists[i]; &#125; 需要注意的有两点： category 的方法没有“完全替换掉”原来类已经有的方法，也就是说如果 category 和原来类都有 methodA，那么category 附加完成之后，类的方法列表里会有两个 methodA category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的 category 的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会退出。 _objc_init-&gt;map_images-&gt;objc-runtime-new.mm-&gt;_read_images-&gt;getCategoryList-&gt; addUnattachedCategoryForClass(把类和category做一个关联映射)-&gt; remethodizeClass-&gt; attachCategoryMethods-&gt;添加到类中相应的list（instanceMethodList，classMethodList）中 Category 和 + load在 + load 方法执行之前，类中就已经加载了 Category 中的方法、属性和协议。而 Category 和 Class 的 + load 方法的调用顺序规则如下： 先调用父类，按照编译顺序，顺序的根据继承关系由父类向子类调用 调用父类之后，再调用父类，按照编译顺序（文件加载到工程中的顺序），依次调用 load 方法除非主动调用，否则只会调用一次 Category 关联对象前面说过，在 Category 中虽然可以添加属性，但是不会生成对应的成员变量，也不能生成 getter、setter 方法。因此，在调用 Category 中声明的属性时会报错(unrecognized selector sent to instance)。 我们可以自己实现 getter、setter 方法，并借助关联对象（Object-C Association Class）来实现 getter、setter方法。关联对象帮助我们在运行阶段将任意的属性关联到一个对象上。具体需要用到这些方法： 12345void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);//以键值对形式添加关联对象id objc_getAssociatedObject(id object, const void *key);//根据 key 获取关联对象void objc_removeAssociatedObjects(id object);//移除所有关联对象 Category 存储关联对象由 AssociationManager 管理，并在全局的 AssociationHashMap 中存储。所有对象的关联对象都在同一个容器中，这个全局容器的数据结构如下图所示 AssociationsManager 内部核心代码 1234567891011121314//AssociationsManager内包含AssociationsHashMapclass AssociationsManager &#123; static AssociationsHashMap *_map;&#125;//AssociationsHashMap内包含ObjectAssociationMapclass AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; //ObjectAssociationMap内包含ObjcAssociationclass ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt;//ObjcAssociation 内包含策略和属性值class ObjcAssociation &#123; uintptr_t _policy; id _value;&#125; map 的 key 是这个对象的指针地址，而这个 map 的 value 又是另外一个 AssociationHashMap，里面保存了关联对象的 KV 对 为什么不放在本类中，由于类的内存布局已预先设置，关联对象添加的属性不能放在原有类的数据结构上，以 Key Value 形式存在全局容器中 如何清除一个关联对象 将 Key 对应的 Value 置为 nil，调用 objc_setAssociatedObject 方法传入一个 nil 值 objc_removeAssociatedObjects(id object), 移除类的所有关联对象（苹果不推荐此用法，可能会导致其他客户对其添加的属性也被移除） 参考文章深入理解Objective-C：Category Category Customizing Existing Classes dyld: Dynamic Linking On OS X","categories":[],"tags":[{"name":"Category","slug":"Category","permalink":"http://Kyson-sun.github.io/tags/Category/"}]}]}