<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ReactiveCocoa</title>
      <link href="/2019/09/19/ReactiveCocoa/ReactiveCocoa/"/>
      <url>/2019/09/19/ReactiveCocoa/ReactiveCocoa/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a> (简称 RAC )，是由 GitHub 团队开发的一款基于 Cocoa 的 FRP 框架。FRP 就是 Functional Reactive Programming (函数响应式编程)，优点是用随时间改变的函数表示用户输入，这样就不需要可变状态了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ReactiveCocoa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>织语 iOS Hybird 框架</title>
      <link href="/2018/03/20/ccwork%20iOS%20Hybird%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/03/20/ccwork%20iOS%20Hybird%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hybird 作为一种混合开发模式，依赖 Native 端的 Web 容器（UIWebView / WKWebView），上层使用 H5、JS 做业务开发。这种开发模式，非常有利于办公协同APP的开放平台搭建，由 Native 端提供API，供第三方使用开发、快速迭代。</p><h2 id="Hybird-App-框架"><a href="#Hybird-App-框架" class="headerlink" title="Hybird App 框架"></a>Hybird App 框架</h2><p>一个完整的 Hybrid APP 框架主要包括 Manager、WebView 、Bridge、Cache 等模块。整个框架设计理念是组合，而不是继承，因此框架设计的不是一个 XXWebView / XXWebViewController 基类，使用者不需要在业务代码中继承 WebView 。框架设计的是一个 Manager 对象，使用者只需要跟自己业务中的任意一种 WebView 进行绑定，就可以拥有 Hybrid 的能力。</p><ul><li>Manager 作为核心， 负责处理 Hybird 业务，校验和注册API</li><li>WebView 作为容器，负责展示前端页面，响应前端交互</li><li>Bridge 作为桥梁，负责 Native 和 JS 之间通信交互</li><li>Cache 作为缓存，负责缓存资源文件等</li></ul><h2 id="WebView-容器"><a href="#WebView-容器" class="headerlink" title="WebView 容器"></a>WebView 容器</h2><p>iOS8 以后苹果推出了一套新的 WKWebView，对于 UIWebView 和 WKWebView 的区别，可以参考 <a href="https://mp.weixin.qq.com/s?__biz=MzI1MTE2NTE1Ng==&mid=2649516616&idx=1&sn=c16a7fc0ddaee2a6d5e1ad10373af9e3&chksm=f1efeac3c69863d5942da9ba250c39e29af97a7c1ac22fce49d65dc3967c49c811b0f566b2c6#rd" target="_blank" rel="noopener">教你使用 WKWebView 的正确姿势</a>，本框架暂时使用 WKWebView 作为容器，针对 WKWebView 的区别，本框架做了一下解决方案：</p><h3 id="Cookie-问题"><a href="#Cookie-问题" class="headerlink" title="Cookie 问题"></a>Cookie 问题</h3><p>前端抛弃对 Cookie 的依赖，改为使用 H5 的 Storage 能力。另 Native 提供存读接口，以备前端使用存储功能。</p><h3 id="NSURLProtocol-支持"><a href="#NSURLProtocol-支持" class="headerlink" title="NSURLProtocol 支持"></a>NSURLProtocol 支持</h3><p>WKWebView 包含一个 browsingContextController 属性对象，该对象提供了 registerSchemeForCustomProtocol 和 unregisterSchemeForCustomProtocol 两个方法，能通过注册 scheme 来代理同类请求，符合注册 scheme 类型的请求会走 NSURLProtocol 协议。但是这种方案存在两个严重缺陷：post 请求 body 数据被清空；对 ATS 支持不足。</p><h3 id="跨域访问"><a href="#跨域访问" class="headerlink" title="跨域访问"></a>跨域访问</h3><p>iOS9 以后，可以通过 KVC 设置 WKPreferences 的 allowFileAccessFromFileURLs 和 allowUniversalAccessFromFileURLs 属性，来打开跨域访问。但是 iOS8 暂不支持。</p><h3 id="跨域白屏的问题"><a href="#跨域白屏的问题" class="headerlink" title="跨域白屏的问题"></a>跨域白屏的问题</h3><p>在 WKWebView 白屏的时候，webView.title 会被置空，因此，可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。</p><h3 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h3><p>针对单个资源文件，可以对该资源地址加时间戳避开缓存。针对全局资源文件，需要手动清理缓存，iOS9 以后，系统提供了缓存管理接口 WKWebsiteDataStore。而 iOS8，只能通过手动删除文件来解决了，WKWebView 的缓存数据会存储在 ~/Library/Caches/BundleID/WebKit/ 目录下，可通过删除该目录来实现清理缓存。</p><h2 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h2><p>由于容器选择是 WKWebView，所以 JS 调用 Native 端有两种方式 URL拦截 和 messageHandler 。本框架采用 messageHandler + evaluatingJavaScript 的方式进行通信交互。</p><h3 id="JS-gt-Native-交互"><a href="#JS-gt-Native-交互" class="headerlink" title="JS -&gt; Native 交互"></a>JS -&gt; Native 交互</h3><h4 id="Native-注入"><a href="#Native-注入" class="headerlink" title="Native 注入"></a>Native 注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置对象注入</span><br><span class="line">[self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;nativeObject&quot;];</span><br><span class="line">//移除对象注入</span><br><span class="line">[self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;nativeObject&quot;];</span><br></pre></td></tr></table></figure><h4 id="JS-调用"><a href="#JS-调用" class="headerlink" title="JS 调用"></a>JS 调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//准备要传给native的数据，包括指令，数据，回调等</span><br><span class="line">var data = &#123;</span><br><span class="line">    action:&apos;xxxx&apos;,</span><br><span class="line">    params:&apos;xxxx&apos;,</span><br><span class="line">    callback:&apos;xxxx&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">//传递给客户端</span><br><span class="line">window.webkit.messageHandlers.nativeObject.postMessage(data);</span><br></pre></td></tr></table></figure><h4 id="Native-接收"><a href="#Native-接收" class="headerlink" title="Native 接收"></a>Native 接收</h4><p>当 JS 开始调用后，会调用到指定的 WKScriptMessageHandler 代理对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">    //1 取出 name 是否与注入 name 匹配</span><br><span class="line">    if (message.name isEqualToString:@&quot;nativeObject&quot;) &#123;</span><br><span class="line">        //2 取出对象，做后续操作</span><br><span class="line">        NSDictionary *msgBody = message.body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Native-gt-JS"><a href="#Native-gt-JS" class="headerlink" title="Native -&gt; JS"></a>Native -&gt; JS</h3><p>对于 WKWebView ，除了evaluatingJavaScript，还有 WKUserScript 这个方式可以执行 JS 代码，他们之间是有区别的</p><ul><li>evaluatingJavaScript 是在客户端执行这条代码的时候立刻去执行当条JS代码</li><li>WKUserScript 是预先准备好JS代码，当 WKWebView 加载 Dom 的时候，执行当条 JS 代码</li></ul><p>很明显这个虽然是一种通信方式，但并不能随时随地进行通信，并不适合选则作为设计 Bridge 的核心方案。</p><h3 id="注入时机"><a href="#注入时机" class="headerlink" title="注入时机"></a>注入时机</h3><p>并不是所有前端页面都需要用到 Native 能力，因此在需要用到 Native 能力的页面，才注入 JS 代码，为其提供 Native 能力。如果需要，使用假跳转至一个指定的 URL, 然后客户端在代理方法 webView:(WKWebView *)webViewdecidePolicyForNavigationAction:decisionHandler: 里判断 URL 是否为指定的 URL，如果是，则执行注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line">    NSURL *url = navigationAction.request.URL;</span><br><span class="line">    if ([url.absoluteString isEqualToString:@&quot;指定URL&quot;]) &#123;</span><br><span class="line">        // 执行注入 JS 代码</span><br><span class="line">        </span><br><span class="line">        decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bridge-框架"><a href="#Bridge-框架" class="headerlink" title="Bridge 框架"></a>Bridge 框架</h3><p>这个 Native 和 JS 的 Bridge 交互如下：<br><img src="/2018/03/20/ccwork iOS Hybird框架/HybirdHandle.png" alt></p><p><strong>Property</strong></p><ul><li>messageHandlers 字典，以 handlerName 作为 key，保存对应 function</li><li>responseCallbacks 字典，以 callbackId 作为 key，保存响应 function</li></ul><p><strong>function</strong></p><ul><li>doSend: 调用另一端方法，传递 message 字典参数</li><li>responseAnotherMethod: 响应另一端的调用，接收 message 字典参数</li></ul><h2 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h2><p>Manager 为整个 Hybrid 核心，负责 JS 方法到 Native 端的映射，可灵活扩展。利用 runtime 特性，使用得到的 className 和 functionName 反射出指定的对象，并执行指定函数。</p><h2 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h2><p>针对打开的 WebView, 是否拥有合法使用 Hybrid 的权限需要进行验证，只有验证通过的页面，才能使用原生提供的能力。Manager 提供入口，具体验证由上层实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)authenticationSignatureParameter:(NSDictionary *)parameter comlete:(void (^)(NSError *error))complete;</span><br></pre></td></tr></table></figure><h2 id="组件协议"><a href="#组件协议" class="headerlink" title="组件协议"></a>组件协议</h2><p>JS 页面加载完，在使用 Native 能力之前，需要进行注册，即告知 Native 当前页面所需要使用的 API 列表。Manager 处理该流程，验证 Native 是否实现该 API，同时把 API 转换成对象，对象遵循以下协议：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@protocol KKWebViewJSApiBaseProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@required</span><br><span class="line">/// api名字</span><br><span class="line">@property (nonatomic, copy) NSString *apiName;</span><br><span class="line">/// 是否支持js多次回调</span><br><span class="line">@property (nonatomic, assign) NSInteger isNeedRegistId;</span><br><span class="line">/// 是否为事件类型，客户端调用，类似发通知给JS</span><br><span class="line">@property (nonatomic, assign) NSInteger isEvent;</span><br><span class="line">/// api接口参数数据</span><br><span class="line">@property (nonatomic, strong) NSDictionary *paramData;</span><br><span class="line">/// api接口响应回调</span><br><span class="line">@property (nonatomic, copy) WVJBResponseCallback responseCallback;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) KKWebViewJavaScriptManager *jsManager;</span><br><span class="line"></span><br><span class="line">@end;</span><br></pre></td></tr></table></figure><h2 id="反射函数"><a href="#反射函数" class="headerlink" title="反射函数"></a>反射函数</h2><p>Manager 把 API 转换成对象时，利用 Objective-C 的 runtime 反射机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class cls = NSClassFromString(className);</span><br><span class="line">if ([cls conformsToProtocol:@protocol(KKWebViewJSApiBaseProtocol)]) &#123;</span><br><span class="line">    id&lt;KKWebViewJSApiBaseProtocol&gt; obj = [[cls alloc] init];</span><br><span class="line">    if ([obj respondsToSelector:NSSelectorFromString(functionName)]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">        [obj performSelector:NSSelectorFromString(functionName)];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        return obj;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;function is not found&quot;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;clss is not found&quot;);</span><br><span class="line">     return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://awhisper.github.io/2018/01/02/hybrid-jscomunication" target="_blank" rel="noopener">从零收拾一个hybrid框架</a></p><p><a href="https://juejin.im/post/5abca877f265da238155b6bc" target="_blank" rel="noopener">JSBridge 的原理</a></p><p><a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="noopener">WKWebView 那些坑</a></p><p><a href="https://www.cnblogs.com/yexiaochai/p/4921635.html" target="_blank" rel="noopener">浅谈 Hybrid 技术的设计与实现</a><br><a href="https://blog.csdn.net/byeweiyang/article/details/75102051" target="_blank" rel="noopener"><br>58 同城 iOS 客户端 Hybrid 框架探索</a></p><p><a href="https://lvwenhan.com/ios/460.html" target="_blank" rel="noopener">自己动手打造基于 WKWebView 的混合开发框架</a></p>]]></content>
      
      
      <categories>
          
          <category> Hybird </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hybird </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>织语 IM 消息 框架设计</title>
      <link href="/2018/03/02/%E7%BB%87%E8%AF%AD-IM-%E6%B6%88%E6%81%AF-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/03/02/%E7%BB%87%E8%AF%AD-IM-%E6%B6%88%E6%81%AF-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如何从零开始设计消息界面，应该考虑哪些问题。<br>架构的选型，消息页面承载了各种各样的业务，不应该所有业务都集中在 VC，随着业务的增长，VC 只会越来越臃肿，合适的架构，不仅便于拓展，也有利于消息页面的长足发展。</p><p>消息页面业务列表：</p><ul><li>消息接收，发送，更新</li><li>消息的上下加载</li><li>不同消息 cell 展示</li><li>cell 长按 menu 事件</li><li>cell 内点击事件</li><li>输入框事件</li><li>不同消息页的展示</li></ul><h2 id="消息界面框架"><a href="#消息界面框架" class="headerlink" title="消息界面框架"></a>消息界面框架</h2><p>消息界面 MessageViewController 继承 UIViewController，由 UITableView(界面)，MessageConfig (消息配置)，MessageInteractor (逻辑控制器) 作为基本构成。</p><h3 id="消息配置类"><a href="#消息配置类" class="headerlink" title="消息配置类"></a>消息配置类</h3><p>APP 内会存在不同消息界面展示需求，如单聊，群聊，公众号，历史消息浏览等，框架抽象出一些常用的配置接口以便于业务方修改界面。配置类不是必须实现的，如果不实现，则使用默认配置。</p><p>配置类具体注入步骤为:</p><ul><li>继承消息类 MessageViewController 。</li><li>创建配置类，实现协议 MessageConfig。</li><li>在继承的消息类中，重写父类接口 - (id<messageconfig>)messageConfig 方法，返回创建的配置类。</messageconfig></li></ul><h3 id="逻辑实现类"><a href="#逻辑实现类" class="headerlink" title="逻辑实现类"></a>逻辑实现类</h3><p>由于消息界面比较复杂，框架抽象出了逻辑实现类接口 MessageInteractor<br>MessageInteractor 由 数据逻辑 MessageDataSource 和 排版逻辑 MessageLayout 两部分接口组成。</p><p>数据逻辑 MessageDataSource 主要用于消息的数据的增删改查，作为界面的数据源，并缓存一些计算的中间数据，避免重复运算，提高性能。</p><p>排版逻辑 MessageLayout 主要用于消息的排版操作， MessageLayout 不关心具体数据，只根据上层控制，对界面排版做出调整。</p><h2 id="消息展示逻辑"><a href="#消息展示逻辑" class="headerlink" title="消息展示逻辑"></a>消息展示逻辑</h2><h3 id="消息普通展示"><a href="#消息普通展示" class="headerlink" title="消息普通展示"></a>消息普通展示</h3><ul><li>消息通过 srvMsgId 和 clientOrder 两者共同排序。srvMsgId，为服务器生成的消息有序 Id。clientOrder 为本地客户端生成的有序数列。消息排序时，先根据 srvMsgId 进行排序，如果srvMsgId 一致，则在比较 clientOrder。正常情况下，发送成功的消息，即拥有唯一 srvMsgId。但客户端新建一条待发送的消息时，该消息的 srvMsgId，取至本地消息最大的 srvMsgId，同时 clientOrder 在最大消息的 clientOrder 上加一。这样子保证了本地消息排序的有序。等到新消息发送成功，服务器返回后，更新该 srvMsgId 为服务器的最新 srvMsgId，同时 clientOrder 置为0。</li></ul><blockquote><p>消息发送成功后，返回 srvMsgId 可能导致排序变化，出于性能考量，不对已展示消息重新排序，等用户下次再进入消息界面，即会展示正确的消息排序。</p></blockquote><ul><li>上拉拉取数据逻辑，异步加载一屏本地数据，如果本地数据不足一屏，则再异步拉取服务器数据。凑满一屏数据后，返回界面展示。当服务器返回无更多数据后，上拉拉取UI控件隐藏</li><li>一直加载老数据，使得数据源消息数大于设定的最大值时，则清楚数据源内排序靠后的老数据，同时向下加载更多 UI 控件变更为显示</li></ul><blockquote><p>上拉拉取时，菊花开始转，tableView 处于滑动状态，offset 一直在变。应该等 tableVew 停止滑动后，再开始进行 tableView 的 reloadData 操作，重设 offset。所以调用 performSelectorOnMainThread:withObject:waitUntilDone:modes: 执行 reloadData 操作，该方法能在 tableView 停止滑动，即 runloop 空闲后执行操作。</p></blockquote><ul><li><p>下拉加载数据逻辑，仅当向下加载更多UI控件显示时，触发。逻辑同上拉拉取逻辑一致。当服务器返回无更多数据后，向下加载更多UI控件隐藏。</p></li><li><p>点击输入框时，界面直接跳转至最新数据展示。以向下加载更多UI控件是否隐藏作为标志位，如果隐藏，说明当前数据即为最新数据，界面直接跳转至末尾。如果显示，则当前数据不是最新数据，则清空界面数据，异步拉取最新一屏本地数据展示，同时异步拉取服务器最新数据，待服务器数据返回后，再和本地数据合并，展示在界面。</p></li><li><p>接收新消息时，后台线程计算Layout，计算完毕后，放入 pendingMessage 数组，在合适的时机，如 tableView 无滑动时，切主线程，一个一个的加入数据源，更新 tableView。如果数据源消息大于设定最大值，则清理数据源内排序靠前的老数据</p></li></ul><h3 id="正常进入消息界面"><a href="#正常进入消息界面" class="headerlink" title="正常进入消息界面"></a>正常进入消息界面</h3><ul><li>同步加载一屏本地数据，同时异步拉取服务器最新数据</li><li>服务器最新数据返回，如果与本地一致，不做处理。如果数据量大于一屏，清楚之前加载数据，替换数据为最新一屏数据。如果数据量小于一屏，则在展示的本地数据后，直接添加最新数据</li><li>向下加载更多UI控件隐藏</li></ul><h3 id="指定跳转某一条消息"><a href="#指定跳转某一条消息" class="headerlink" title="指定跳转某一条消息"></a>指定跳转某一条消息</h3><ul><li>以该条消息为基准，异步上下加载一屏本地数据，如果本地数据不足一屏，则再异步拉取服务器数据。凑满一屏数据后，返回界面展示</li><li>向下加载更多UI控件不隐藏</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 消息框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Category 方法的调用</title>
      <link href="/2017/08/27/Category-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/"/>
      <url>/2017/08/27/Category-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Category 是 Objective-C 2.0之后添加的，Category 的主要作用是为已经存在的类添加方法。另外，Apple 还推荐了 Category 的另外两个使用场景。</p><ol><li>可以把类的实现分开在几个不同的文件里。这样可以减少单个文件的体积，可以把不同的功能组织到不同的文件里，可以多个开发者维护一个类，可以按需加载想要的 Category</li><li>声明私有方法</li></ol><p>另外我们也可以使用 Category 实现一些意想不到的功能</p><ol><li>模拟多继承</li><li>公开 Framework 的私有方法</li></ol><h3 id="Category-和-Extension"><a href="#Category-和-Extension" class="headerlink" title="Category 和 Extension"></a>Category 和 Extension</h3><ol><li>extension 在编译期决议，他就是类的一部分，在编译期和头文件里的 @interface 以及实现文件里的 @impletment 一起形成一个完整的类，它伴随类的产生和消亡。</li><li>extension 一般来隐藏类的私有信息，但是必须要有类的源码才能为一个类添加extension，所以无法为系统的类添加extension</li><li>category 则是运行期决议</li><li>extension 可以添加实例变量，而 category 无法添加实例变量。因为在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局</li></ol><h3 id="Category-源码"><a href="#Category-源码" class="headerlink" title="Category 源码"></a>Category 源码</h3><p>Category 在 objc-runtime-new.h 中，Category（分类）被定义为 category_t 结构体。category_t 结构体的数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct category_t *Category;</span><br><span class="line"></span><br><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name;                                // 类名</span><br><span class="line">    classref_t cls;                                  // 类，在运行时阶段通过 clasee_name（类名）对应到类对象</span><br><span class="line">    struct method_list_t *instanceMethods;           // Category 中所有添加的对象方法列表</span><br><span class="line">    struct method_list_t *classMethods;              // Category 中所有添加的类方法列表</span><br><span class="line">    struct protocol_list_t *protocols;               // Category 中实现的所有协议列表</span><br><span class="line">    struct property_list_t *instanceProperties;      // Category 中添加的所有属性</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从 Category 的结构体中可以看出，Category 可以为类添加实例方法、类方法、protocol和property，但是并不能添加成员变量</p><p>People.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface People : NSObject</span><br><span class="line"></span><br><span class="line">- (void)run;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface People (Addition)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (void)run;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>People.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;People.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation People</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation People (Addition)</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, @selector(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run &#123;</span><br><span class="line">    NSLog(@&quot;%@ can run&quot;,self.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>使用clang命令查看 Category 到底是啥玩意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc People.m</span><br></pre></td></tr></table></figure><p>我们会得到一个巨大无比的 cpp 文件，我们先忽略文件的大小，先看一下文件最后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[3];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_People_$_Addition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">3,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;setName:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_People_Addition_setName_&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;name&quot;, &quot;@16@0:8&quot;, (void *)_I_People_Addition_name&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;run&quot;, &quot;v16@0:8&quot;, (void *)_I_People_Addition_run&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct /*_prop_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _prop_t)</span><br><span class="line">unsigned int count_of_properties;</span><br><span class="line">struct _prop_t prop_list[1];</span><br><span class="line">&#125; _OBJC_$_PROP_LIST_People_$_Addition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_prop_t),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;&quot;name&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_People;</span><br><span class="line"></span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_People_$_Addition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = </span><br><span class="line">&#123;</span><br><span class="line">&quot;People&quot;,</span><br><span class="line">0, // &amp;OBJC_CLASS_$_People,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_People_$_Addition,//生成实例方法列表</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_People_$_Addition,//生成属性列表</span><br><span class="line">&#125;;</span><br><span class="line">static void OBJC_CATEGORY_SETUP_$_People_$_Addition(void ) &#123;</span><br><span class="line">_OBJC_$_CATEGORY_People_$_Addition.cls = &amp;OBJC_CLASS_$_People;</span><br><span class="line">&#125;</span><br><span class="line">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</span><br><span class="line">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">(void *)&amp;OBJC_CATEGORY_SETUP_$_People_$_Addition,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;OBJC_CLASS_$_People,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_People_$_Addition,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此我们可以看到，</p><ol><li>编译器生成了实例方法列表 <em>OBJC</em>$<em>CATEGORY_INSTANCE_METHODS_People</em>$<em>Addition 和属性列表 _OBJC</em>$<em>PROP_LIST_People</em>$_Addition， 且实例方法列表里填充的正是我们在 category 中写的方法 run ，而属性列表中正是我们在 category 中声明的 name 属性。另外 category 的名字用来给各种列表以及后面的 category 结构体本身命名，用 static 来修饰，所以在一个编译单元里我们的 category 名不能重复，否则会编译错误</li><li>编译器生成了 category 本身 <em>OBJC</em>$<em>CATEGORY_People</em>$_Addition，并用前面生成的列表来初始化 category 本身</li><li>编译器在 DATA 段下的 objc_catlist section 里保存了一个大小为 1 的 category_t 的数组 L_OBJC_LABEL_CATEGORY_ （如果有多个 category 会生成对应长度的数组），用于运行期 category 加载</li></ol><h3 id="category-加载"><a href="#category-加载" class="headerlink" title="category 加载"></a>category 加载</h3><p>Objective-C 的运行是依赖 OC 的 runtime 的，而 OC 的 runtime 是通过 dyld 动态加载的</p><ol><li>OC 运行时入口方法 （objc-os.mm）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line">   </span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line">       </span><br><span class="line">    // Register for unmap first, in case some +load unmaps something</span><br><span class="line">    _dyld_register_func_for_remove_image(&amp;unmap_image);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_bound,</span><br><span class="line">                                             1/*batch*/, &amp;map_images);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>category 被附加到类上面是在 map_images 的时候发生的，在 new-API 的标准下，_objc_init 里面的调用的 map_images 最终会调用 objc-runtime-new.mm 里面的 _read_images 方法，而在 _read_images 方法的结尾，有以下的代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// Discover categories. </span><br><span class="line">    for (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist =</span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            class_t *cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">            if (!cls) &#123;</span><br><span class="line">                // Category&apos;s target class is missing (probably weak-linked).</span><br><span class="line">                // Disavow any knowledge of this category.</span><br><span class="line">                catlist[i] = NULL;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br><span class="line">                                 &quot;missing weak-linked target class&quot;,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Process this category. </span><br><span class="line">            // First, register the category with its target class. </span><br><span class="line">            // Then, rebuild the class&apos;s method lists (etc) if </span><br><span class="line">            // the class is realized. </span><br><span class="line">            BOOL classExists = NO;</span><br><span class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols </span><br><span class="line">                ||  cat-&gt;instanceProperties)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                if (isRealized(cls)) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,</span><br><span class="line">                                 getName(cls), cat-&gt;name,</span><br><span class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols </span><br><span class="line">                /* ||  cat-&gt;classProperties */)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);</span><br><span class="line">                if (isRealized(cls-&gt;isa)) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;isa);</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,</span><br><span class="line">                                 getName(cls), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先，我们拿到的 catlist 就是上节中讲到的编译器为我们准备的 category_t 数组</p><p>这段代码的意思就是：</p><ol><li>把 category 的实例方法、协议以及属性添加到类上</li><li>把 category 的类方法和协议添加到类的 meta class 上</li></ol><p>我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：</p><p>在上述的代码片段里，addUnattachedCategoryForClass 只是把类和 category 做一个关联映射，而 remethodizeClass 才是真正去做添加的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static void remethodizeClass(class_t *cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    BOOL isMeta;</span><br><span class="line"></span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    isMeta = isMetaClass(cls);</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls))) &#123;</span><br><span class="line">        chained_property_list *newproperties;</span><br><span class="line">        const protocol_list_t **newprotos;</span><br><span class="line">       </span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,</span><br><span class="line">                         getName(cls), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        // Update methods, properties, protocols</span><br><span class="line">       </span><br><span class="line">        BOOL vtableAffected = NO;</span><br><span class="line">        attachCategoryMethods(cls, cats, &amp;vtableAffected);</span><br><span class="line">       </span><br><span class="line">        newproperties = buildPropertyList(NULL, cats, isMeta);</span><br><span class="line">        if (newproperties) &#123;</span><br><span class="line">            newproperties-&gt;next = cls-&gt;data()-&gt;properties;</span><br><span class="line">            cls-&gt;data()-&gt;properties = newproperties;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        newprotos = buildProtocolList(cats, NULL, cls-&gt;data()-&gt;protocols);</span><br><span class="line">        if (cls-&gt;data()-&gt;protocols  &amp;&amp;  cls-&gt;data()-&gt;protocols != newprotos) &#123;</span><br><span class="line">            _free_internal(cls-&gt;data()-&gt;protocols);</span><br><span class="line">        &#125;</span><br><span class="line">        cls-&gt;data()-&gt;protocols = newprotos;</span><br><span class="line">       </span><br><span class="line">        _free_internal(cats);</span><br><span class="line"></span><br><span class="line">        // Update method caches and vtables</span><br><span class="line">        flushCaches(cls);</span><br><span class="line">        if (vtableAffected) flushVtables(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于添加类的实例方法而言，又会去调用 attachCategoryMethods 这个方法，我们去看下 attachCategoryMethods ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void </span><br><span class="line">attachCategoryMethods(class_t *cls, category_list *cats,</span><br><span class="line">                      BOOL *inoutVtablesAffected)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    BOOL isMeta = isMetaClass(cls);</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        _malloc_internal(cats-&gt;count * sizeof(*mlists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    BOOL fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= cats-&gt;list[i].fromBundle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);</span><br><span class="line"></span><br><span class="line">    _free_internal(mlists);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>attachCategoryMethods 只是把所有 category 的实例方法列表拼成了一个大的实例方法列表，然后转交给了 attachMethodLists 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">for (uint32_t m = 0;</span><br><span class="line">        (scanForCustomRR || scanForCustomAWZ)  &amp;&amp;  m &lt; mlist-&gt;count;</span><br><span class="line">        m++)</span><br><span class="line">   &#123;</span><br><span class="line">       SEL sel = method_list_nth(mlist, m)-&gt;name;</span><br><span class="line">       if (scanForCustomRR  &amp;&amp;  isRRSelector(sel)) &#123;</span><br><span class="line">           cls-&gt;setHasCustomRR();</span><br><span class="line">           scanForCustomRR = false;</span><br><span class="line">       &#125; else if (scanForCustomAWZ  &amp;&amp;  isAWZSelector(sel)) &#123;</span><br><span class="line">           cls-&gt;setHasCustomAWZ();</span><br><span class="line">           scanForCustomAWZ = false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   // Fill method list array</span><br><span class="line">   newLists[newCount++] = mlist;</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line"></span><br><span class="line">   // Copy old methods to the method list array</span><br><span class="line">   for (i = 0; i &lt; oldCount; i++) &#123;</span><br><span class="line">       newLists[newCount++] = oldLists[i];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要注意的有两点：</p><ol><li><p>category 的方法没有“完全替换掉”原来类已经有的方法，也就是说如果 category 和原来类都有 methodA，那么category 附加完成之后，类的方法列表里会有两个 methodA</p></li><li><p>category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的 category 的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会退出。</p></li></ol><p>_objc_init-&gt;map_images-&gt;objc-runtime-new.mm-&gt;_read_images-&gt;getCategoryList-&gt; addUnattachedCategoryForClass(把类和category做一个关联映射)-&gt; remethodizeClass-&gt; attachCategoryMethods-&gt;添加到类中相应的list（instanceMethodList，classMethodList）中</p><h3 id="Category-和-load"><a href="#Category-和-load" class="headerlink" title="Category 和 + load"></a>Category 和 + load</h3><p>在 + load 方法执行之前，类中就已经加载了 Category 中的方法、属性和协议。而 Category 和 Class 的 + load 方法的调用顺序规则如下：</p><ol><li>先调用父类，按照编译顺序，顺序的根据继承关系由父类向子类调用</li><li>调用父类之后，再调用父类，按照编译顺序（文件加载到工程中的顺序），依次调用</li><li><ul><li>load 方法除非主动调用，否则只会调用一次</li></ul></li></ol><h3 id="Category-关联对象"><a href="#Category-关联对象" class="headerlink" title="Category 关联对象"></a>Category 关联对象</h3><p>前面说过，在 Category 中虽然可以添加属性，但是不会生成对应的成员变量，也不能生成 getter、setter 方法。因此，在调用 Category 中声明的属性时会报错(unrecognized selector sent to instance)。</p><p>我们可以自己实现 getter、setter 方法，并借助关联对象（Object-C Association Class）来实现 getter、setter方法。关联对象帮助我们在运行阶段将任意的属性关联到一个对象上。具体需要用到这些方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);//以键值对形式添加关联对象</span><br><span class="line"></span><br><span class="line">id objc_getAssociatedObject(id object, const void *key);//根据 key 获取关联对象</span><br><span class="line"></span><br><span class="line">void objc_removeAssociatedObjects(id object);//移除所有关联对象</span><br></pre></td></tr></table></figure><h3 id="Category-存储"><a href="#Category-存储" class="headerlink" title="Category 存储"></a>Category 存储</h3><p>关联对象由 AssociationManager 管理，并在全局的 AssociationHashMap 中存储。所有对象的关联对象都在同一个容器中，这个全局容器的数据结构如下图所示</p><p><img src="/2017/08/27/Category-方法的调用/1915113-aedbce0b73e014c4.png" alt></p><p>AssociationsManager 内部核心代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//AssociationsManager内包含AssociationsHashMap</span><br><span class="line">class AssociationsManager &#123;</span><br><span class="line">    static AssociationsHashMap *_map;</span><br><span class="line">&#125;</span><br><span class="line">//AssociationsHashMap内包含ObjectAssociationMap</span><br><span class="line">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; </span><br><span class="line">//ObjectAssociationMap内包含ObjcAssociation</span><br><span class="line">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt;</span><br><span class="line"></span><br><span class="line">//ObjcAssociation 内包含策略和属性值</span><br><span class="line">class ObjcAssociation &#123;</span><br><span class="line">        uintptr_t _policy;</span><br><span class="line">        id _value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map 的 key 是这个对象的指针地址，而这个 map 的 value 又是另外一个 AssociationHashMap，里面保存了关联对象的 KV 对</p><blockquote><p>为什么不放在本类中，由于类的内存布局已预先设置，关联对象添加的属性不能放在原有类的数据结构上，以 Key Value 形式存在全局容器中</p></blockquote><h3 id="如何清除一个关联对象"><a href="#如何清除一个关联对象" class="headerlink" title="如何清除一个关联对象"></a>如何清除一个关联对象</h3><ol><li>将 Key 对应的 Value 置为 nil，调用 objc_setAssociatedObject 方法传入一个 nil 值</li><li>objc_removeAssociatedObjects(id object), 移除类的所有关联对象（苹果不推荐此用法，可能会导致其他客户对其添加的属性也被移除）</li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://tech.meituan.com/2015/03/03/diveintocategory.html" target="_blank" rel="noopener">深入理解Objective-C：Category</a></p><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" target="_blank" rel="noopener">Category</a></p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="noopener">Customizing Existing Classes</a></p><p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="noopener">dyld: Dynamic Linking On OS X</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Category </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
