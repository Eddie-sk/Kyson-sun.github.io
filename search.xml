<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>织语 iOS Hybird 框架</title>
      <link href="/2018/03/20/ccwork%20iOS%20Hybird%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/03/20/ccwork%20iOS%20Hybird%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hybird 作为一种混合开发模式，依赖 Native 端的 Web 容器（UIWebView / WKWebView），上层使用 H5、JS 做业务开发。这种开发模式，非常有利于办公协同APP的开放平台搭建，由 Native 端提供API，供第三方使用开发、快速迭代。</p><h2 id="Hybird-App-框架"><a href="#Hybird-App-框架" class="headerlink" title="Hybird App 框架"></a>Hybird App 框架</h2><p>一个完整的 Hybrid APP 框架主要包括 Manager、WebView 、Bridge、Cache 等模块。整个框架设计理念是组合，而不是继承，因此框架设计的不是一个 XXWebView / XXWebViewController 基类，使用者不需要在业务代码中继承 WebView 。框架设计的是一个 Manager 对象，使用者只需要跟自己业务中的任意一种 WebView 进行绑定，就可以拥有 Hybrid 的能力。</p><ul><li>Manager 作为核心， 负责处理 Hybird 业务，校验和注册API</li><li>WebView 作为容器，负责展示前端页面，响应前端交互</li><li>Bridge 作为桥梁，负责 Native 和 JS 之间通信交互</li><li>Cache 作为缓存，负责缓存资源文件等</li></ul><h2 id="WebView-容器"><a href="#WebView-容器" class="headerlink" title="WebView 容器"></a>WebView 容器</h2><p>iOS8 以后苹果推出了一套新的 WKWebView，对于 UIWebView 和 WKWebView 的区别，可以参考 <a href="https://mp.weixin.qq.com/s?__biz=MzI1MTE2NTE1Ng==&mid=2649516616&idx=1&sn=c16a7fc0ddaee2a6d5e1ad10373af9e3&chksm=f1efeac3c69863d5942da9ba250c39e29af97a7c1ac22fce49d65dc3967c49c811b0f566b2c6#rd" target="_blank" rel="noopener">教你使用 WKWebView 的正确姿势</a>，本框架暂时使用 WKWebView 作为容器，针对 WKWebView 的区别，本框架做了一下解决方案：</p><h3 id="Cookie-问题"><a href="#Cookie-问题" class="headerlink" title="Cookie 问题"></a>Cookie 问题</h3><p>前端抛弃对 Cookie 的依赖，改为使用 H5 的 Storage 能力。另 Native 提供存读接口，以备前端使用存储功能。</p><h3 id="NSURLProtocol-支持"><a href="#NSURLProtocol-支持" class="headerlink" title="NSURLProtocol 支持"></a>NSURLProtocol 支持</h3><p>WKWebView 包含一个 browsingContextController 属性对象，该对象提供了 registerSchemeForCustomProtocol 和 unregisterSchemeForCustomProtocol 两个方法，能通过注册 scheme 来代理同类请求，符合注册 scheme 类型的请求会走 NSURLProtocol 协议。但是这种方案存在两个严重缺陷：post 请求 body 数据被清空；对 ATS 支持不足。</p><h3 id="跨域访问"><a href="#跨域访问" class="headerlink" title="跨域访问"></a>跨域访问</h3><p>iOS9 以后，可以通过 KVC 设置 WKPreferences 的 allowFileAccessFromFileURLs 和 allowUniversalAccessFromFileURLs 属性，来打开跨域访问。但是 iOS8 暂不支持。</p><h3 id="跨域白屏的问题"><a href="#跨域白屏的问题" class="headerlink" title="跨域白屏的问题"></a>跨域白屏的问题</h3><p>在 WKWebView 白屏的时候，webView.title 会被置空，因此，可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。</p><h3 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h3><p>针对单个资源文件，可以对该资源地址加时间戳避开缓存。针对全局资源文件，需要手动清理缓存，iOS9 以后，系统提供了缓存管理接口 WKWebsiteDataStore。而 iOS8，只能通过手动删除文件来解决了，WKWebView 的缓存数据会存储在 ~/Library/Caches/BundleID/WebKit/ 目录下，可通过删除该目录来实现清理缓存。</p><h2 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h2><p>由于容器选择是 WKWebView，所以 JS 调用 Native 端有两种方式 URL拦截 和 messageHandler 。本框架采用 messageHandler + evaluatingJavaScript 的方式进行通信交互。</p><h3 id="JS-gt-Native-交互"><a href="#JS-gt-Native-交互" class="headerlink" title="JS -&gt; Native 交互"></a>JS -&gt; Native 交互</h3><h4 id="Native-注入"><a href="#Native-注入" class="headerlink" title="Native 注入"></a>Native 注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置对象注入</span><br><span class="line">[self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;nativeObject&quot;];</span><br><span class="line">//移除对象注入</span><br><span class="line">[self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;nativeObject&quot;];</span><br></pre></td></tr></table></figure><h4 id="JS-调用"><a href="#JS-调用" class="headerlink" title="JS 调用"></a>JS 调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//准备要传给native的数据，包括指令，数据，回调等</span><br><span class="line">var data = &#123;</span><br><span class="line">    action:&apos;xxxx&apos;,</span><br><span class="line">    params:&apos;xxxx&apos;,</span><br><span class="line">    callback:&apos;xxxx&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">//传递给客户端</span><br><span class="line">window.webkit.messageHandlers.nativeObject.postMessage(data);</span><br></pre></td></tr></table></figure><h4 id="Native-接收"><a href="#Native-接收" class="headerlink" title="Native 接收"></a>Native 接收</h4><p>当 JS 开始调用后，会调用到指定的 WKScriptMessageHandler 代理对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">    //1 取出 name 是否与注入 name 匹配</span><br><span class="line">    if (message.name isEqualToString:@&quot;nativeObject&quot;) &#123;</span><br><span class="line">        //2 取出对象，做后续操作</span><br><span class="line">        NSDictionary *msgBody = message.body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Native-gt-JS"><a href="#Native-gt-JS" class="headerlink" title="Native -&gt; JS"></a>Native -&gt; JS</h3><p>对于 WKWebView ，除了evaluatingJavaScript，还有 WKUserScript 这个方式可以执行 JS 代码，他们之间是有区别的</p><ul><li>evaluatingJavaScript 是在客户端执行这条代码的时候立刻去执行当条JS代码</li><li>WKUserScript 是预先准备好JS代码，当 WKWebView 加载 Dom 的时候，执行当条 JS 代码</li></ul><p>很明显这个虽然是一种通信方式，但并不能随时随地进行通信，并不适合选则作为设计 Bridge 的核心方案。</p><h3 id="注入时机"><a href="#注入时机" class="headerlink" title="注入时机"></a>注入时机</h3><p>并不是所有前端页面都需要用到 Native 能力，因此在需要用到 Native 能力的页面，才注入 JS 代码，为其提供 Native 能力。如果需要，使用假跳转至一个指定的 URL, 然后客户端在代理方法 webView:(WKWebView *)webViewdecidePolicyForNavigationAction:decisionHandler: 里判断 URL 是否为指定的 URL，如果是，则执行注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line">    NSURL *url = navigationAction.request.URL;</span><br><span class="line">    if ([url.absoluteString isEqualToString:@&quot;指定URL&quot;]) &#123;</span><br><span class="line">        // 执行注入 JS 代码</span><br><span class="line">        </span><br><span class="line">        decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bridge-框架"><a href="#Bridge-框架" class="headerlink" title="Bridge 框架"></a>Bridge 框架</h3><p>这个 Native 和 JS 的 Bridge 交互如下：<br><img src="/2018/03/20/ccwork iOS Hybird框架/HybirdHandle.png" alt></p><p><strong>Property</strong></p><ul><li>messageHandlers 字典，以 handlerName 作为 key，保存对应 function</li><li>responseCallbacks 字典，以 callbackId 作为 key，保存响应 function</li></ul><p><strong>function</strong></p><ul><li>doSend: 调用另一端方法，传递 message 字典参数</li><li>responseAnotherMethod: 响应另一端的调用，接收 message 字典参数</li></ul><h2 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h2><p>Manager 为整个 Hybrid 核心，负责 JS 方法到 Native 端的映射，可灵活扩展。利用 runtime 特性，使用得到的 className 和 functionName 反射出指定的对象，并执行指定函数。</p><h2 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h2><p>针对打开的 WebView, 是否拥有合法使用 Hybrid 的权限需要进行验证，只有验证通过的页面，才能使用原生提供的能力。Manager 提供入口，具体验证由上层实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)authenticationSignatureParameter:(NSDictionary *)parameter comlete:(void (^)(NSError *error))complete;</span><br></pre></td></tr></table></figure><h2 id="组件协议"><a href="#组件协议" class="headerlink" title="组件协议"></a>组件协议</h2><p>JS 页面加载完，在使用 Native 能力之前，需要进行注册，即告知 Native 当前页面所需要使用的 API 列表。Manager 处理该流程，验证 Native 是否实现该 API，同时把 API 转换成对象，对象遵循以下协议：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@protocol KKWebViewJSApiBaseProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@required</span><br><span class="line">/// api名字</span><br><span class="line">@property (nonatomic, copy) NSString *apiName;</span><br><span class="line">/// 是否支持js多次回调</span><br><span class="line">@property (nonatomic, assign) NSInteger isNeedRegistId;</span><br><span class="line">/// 是否为事件类型，客户端调用，类似发通知给JS</span><br><span class="line">@property (nonatomic, assign) NSInteger isEvent;</span><br><span class="line">/// api接口参数数据</span><br><span class="line">@property (nonatomic, strong) NSDictionary *paramData;</span><br><span class="line">/// api接口响应回调</span><br><span class="line">@property (nonatomic, copy) WVJBResponseCallback responseCallback;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) KKWebViewJavaScriptManager *jsManager;</span><br><span class="line"></span><br><span class="line">@end;</span><br></pre></td></tr></table></figure><h2 id="反射函数"><a href="#反射函数" class="headerlink" title="反射函数"></a>反射函数</h2><p>Manager 把 API 转换成对象时，利用 Objective-C 的 runtime 反射机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class cls = NSClassFromString(className);</span><br><span class="line">if ([cls conformsToProtocol:@protocol(KKWebViewJSApiBaseProtocol)]) &#123;</span><br><span class="line">    id&lt;KKWebViewJSApiBaseProtocol&gt; obj = [[cls alloc] init];</span><br><span class="line">    if ([obj respondsToSelector:NSSelectorFromString(functionName)]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">        [obj performSelector:NSSelectorFromString(functionName)];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        return obj;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;function is not found&quot;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;clss is not found&quot;);</span><br><span class="line">     return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://awhisper.github.io/2018/01/02/hybrid-jscomunication" target="_blank" rel="noopener">从零收拾一个hybrid框架</a></p><p><a href="https://juejin.im/post/5abca877f265da238155b6bc" target="_blank" rel="noopener">JSBridge 的原理</a></p><p><a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="noopener">WKWebView 那些坑</a></p><p><a href="https://www.cnblogs.com/yexiaochai/p/4921635.html" target="_blank" rel="noopener">浅谈 Hybrid 技术的设计与实现</a><br><a href="https://blog.csdn.net/byeweiyang/article/details/75102051" target="_blank" rel="noopener"><br>58 同城 iOS 客户端 Hybrid 框架探索</a></p><p><a href="https://lvwenhan.com/ios/460.html" target="_blank" rel="noopener">自己动手打造基于 WKWebView 的混合开发框架</a></p>]]></content>
      
      
      <categories>
          
          <category> Hybird </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用小技能</title>
      <link href="/2018/03/12/hexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E8%83%BD/"/>
      <url>/2018/03/12/hexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="插入本地图片"><a href="#插入本地图片" class="headerlink" title="插入本地图片"></a>插入本地图片</h2><p>Hexo 插入本地图片的路径让人十分头疼，因为生成 public 的 html 时，每一篇都是在年月日做文件夹目录的文件下，例如</p><pre><code>/blog/public/2018/03/12/Hexo使用小技巧</code></pre><p>而主页的 html 文件又不在这个文件下，与博文的目录不同</p><pre><code>/blog/public</code></pre><p>这与在 _posts 目录下边写博客的 md 文件目录完全不同。</p><p>而 hexo 官方文档为我们提供了一种插入图片的方法，但是这与我们平常编写 Markdown 文件的语法差别很大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>那么 Hexo 有没有能像 Markdown 的语法一样插入本地图片呢，Hexo 为我们提供了一个插件，如下。</p><h3 id="Hexo-配置文件"><a href="#Hexo-配置文件" class="headerlink" title="Hexo 配置文件"></a>Hexo 配置文件</h3><p>在设置文件中加入选项配置：</p><pre><code>post_asset_folder: true</code></pre><p>这个配置实际上是在我们生成文件 ( hexo new )<br>的时候，会在 /source/_posts 文件夹下创建一个文件名相同的文件夹，可以在此文件夹下放入图片，或者附件。</p><h3 id="安装-hexo-asset-image-插件"><a href="#安装-hexo-asset-image-插件" class="headerlink" title="安装 hexo-asset-image 插件"></a>安装 hexo-asset-image 插件</h3><pre><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></pre><p>插件安装完成后，实际上是存放在下面这个文件夹中</p><pre><code>/node_modules/hexo-asset-image</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hexo使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
