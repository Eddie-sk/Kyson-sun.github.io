<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>织语 iOS Hybird 框架</title>
      <link href="/2018/03/20/ccwork%20iOS%20Hybird%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/03/20/ccwork%20iOS%20Hybird%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hybird 作为一种混合开发模式，依赖 Native 端的 Web 容器（UIWebView / WKWebView），上层使用 H5、JS 做业务开发。这种开发模式，非常有利于办公协同APP的开放平台搭建，由 Native 端提供API，供第三方使用开发、快速迭代。</p><h2 id="Hybird-App-框架"><a href="#Hybird-App-框架" class="headerlink" title="Hybird App 框架"></a>Hybird App 框架</h2><p>一个完整的 Hybrid APP 框架主要包括 Manager、WebView 、Bridge、Cache 等模块。整个框架设计理念是组合，而不是继承，因此框架设计的不是一个 XXWebView / XXWebViewController 基类，使用者不需要在业务代码中继承 WebView 。框架设计的是一个 Manager 对象，使用者只需要跟自己业务中的任意一种 WebView 进行绑定，就可以拥有 Hybrid 的能力。</p><ul><li>Manager 作为核心， 负责处理 Hybird 业务，校验和注册API</li><li>WebView 作为容器，负责展示前端页面，响应前端交互</li><li>Bridge 作为桥梁，负责 Native 和 JS 之间通信交互</li><li>Cache 作为缓存，负责缓存资源文件等</li></ul><h2 id="WebView-容器"><a href="#WebView-容器" class="headerlink" title="WebView 容器"></a>WebView 容器</h2><p>iOS8 以后苹果推出了一套新的 WKWebView，对于 UIWebView 和 WKWebView 的区别，可以参考 <a href="https://mp.weixin.qq.com/s?__biz=MzI1MTE2NTE1Ng==&mid=2649516616&idx=1&sn=c16a7fc0ddaee2a6d5e1ad10373af9e3&chksm=f1efeac3c69863d5942da9ba250c39e29af97a7c1ac22fce49d65dc3967c49c811b0f566b2c6#rd" target="_blank" rel="noopener">教你使用 WKWebView 的正确姿势</a>，本框架暂时使用 WKWebView 作为容器，针对 WKWebView 的区别，本框架做了一下解决方案：</p><h3 id="Cookie-问题"><a href="#Cookie-问题" class="headerlink" title="Cookie 问题"></a>Cookie 问题</h3><p>前端抛弃对 Cookie 的依赖，改为使用 H5 的 Storage 能力。另 Native 提供存读接口，以备前端使用存储功能。</p><h3 id="NSURLProtocol-支持"><a href="#NSURLProtocol-支持" class="headerlink" title="NSURLProtocol 支持"></a>NSURLProtocol 支持</h3><p>WKWebView 包含一个 browsingContextController 属性对象，该对象提供了 registerSchemeForCustomProtocol 和 unregisterSchemeForCustomProtocol 两个方法，能通过注册 scheme 来代理同类请求，符合注册 scheme 类型的请求会走 NSURLProtocol 协议。但是这种方案存在两个严重缺陷：post 请求 body 数据被清空；对 ATS 支持不足。</p><h3 id="跨域访问"><a href="#跨域访问" class="headerlink" title="跨域访问"></a>跨域访问</h3><p>iOS9 以后，可以通过 KVC 设置 WKPreferences 的 allowFileAccessFromFileURLs 和 allowUniversalAccessFromFileURLs 属性，来打开跨域访问。但是 iOS8 暂不支持。</p><h3 id="跨域白屏的问题"><a href="#跨域白屏的问题" class="headerlink" title="跨域白屏的问题"></a>跨域白屏的问题</h3><p>在 WKWebView 白屏的时候，webView.title 会被置空，因此，可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。</p><h3 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h3><p>针对单个资源文件，可以对该资源地址加时间戳避开缓存。针对全局资源文件，需要手动清理缓存，iOS9 以后，系统提供了缓存管理接口 WKWebsiteDataStore。而 iOS8，只能通过手动删除文件来解决了，WKWebView 的缓存数据会存储在 ~/Library/Caches/BundleID/WebKit/ 目录下，可通过删除该目录来实现清理缓存。</p><h2 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h2><p>由于容器选择是 WKWebView，所以 JS 调用 Native 端有两种方式 URL拦截 和 messageHandler 。本框架采用 messageHandler + evaluatingJavaScript 的方式进行通信交互。</p><h3 id="JS-gt-Native-交互"><a href="#JS-gt-Native-交互" class="headerlink" title="JS -&gt; Native 交互"></a>JS -&gt; Native 交互</h3><h4 id="Native-注入"><a href="#Native-注入" class="headerlink" title="Native 注入"></a>Native 注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置对象注入</span><br><span class="line">[self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;nativeObject&quot;];</span><br><span class="line">//移除对象注入</span><br><span class="line">[self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;nativeObject&quot;];</span><br></pre></td></tr></table></figure><h4 id="JS-调用"><a href="#JS-调用" class="headerlink" title="JS 调用"></a>JS 调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//准备要传给native的数据，包括指令，数据，回调等</span><br><span class="line">var data = &#123;</span><br><span class="line">    action:&apos;xxxx&apos;,</span><br><span class="line">    params:&apos;xxxx&apos;,</span><br><span class="line">    callback:&apos;xxxx&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">//传递给客户端</span><br><span class="line">window.webkit.messageHandlers.nativeObject.postMessage(data);</span><br></pre></td></tr></table></figure><h4 id="Native-接收"><a href="#Native-接收" class="headerlink" title="Native 接收"></a>Native 接收</h4><p>当 JS 开始调用后，会调用到指定的 WKScriptMessageHandler 代理对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">    //1 取出 name 是否与注入 name 匹配</span><br><span class="line">    if (message.name isEqualToString:@&quot;nativeObject&quot;) &#123;</span><br><span class="line">        //2 取出对象，做后续操作</span><br><span class="line">        NSDictionary *msgBody = message.body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Native-gt-JS"><a href="#Native-gt-JS" class="headerlink" title="Native -&gt; JS"></a>Native -&gt; JS</h3><p>对于 WKWebView ，除了evaluatingJavaScript，还有 WKUserScript 这个方式可以执行 JS 代码，他们之间是有区别的</p><ul><li>evaluatingJavaScript 是在客户端执行这条代码的时候立刻去执行当条JS代码</li><li>WKUserScript 是预先准备好JS代码，当 WKWebView 加载 Dom 的时候，执行当条 JS 代码</li></ul><p>很明显这个虽然是一种通信方式，但并不能随时随地进行通信，并不适合选则作为设计 Bridge 的核心方案。</p><h3 id="注入时机"><a href="#注入时机" class="headerlink" title="注入时机"></a>注入时机</h3><p>并不是所有前端页面都需要用到 Native 能力，因此在需要用到 Native 能力的页面，才注入 JS 代码，为其提供 Native 能力。如果需要，使用假跳转至一个指定的 URL, 然后客户端在代理方法 webView:(WKWebView *)webViewdecidePolicyForNavigationAction:decisionHandler: 里判断 URL 是否为指定的 URL，如果是，则执行注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line">    NSURL *url = navigationAction.request.URL;</span><br><span class="line">    if ([url.absoluteString isEqualToString:@&quot;指定URL&quot;]) &#123;</span><br><span class="line">        // 执行注入 JS 代码</span><br><span class="line">        </span><br><span class="line">        decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bridge-框架"><a href="#Bridge-框架" class="headerlink" title="Bridge 框架"></a>Bridge 框架</h3><p>这个 Native 和 JS 的 Bridge 交互如下：<br><img src="/2018/03/20/ccwork iOS Hybird框架/HybirdHandle.png" alt></p><p><strong>Property</strong></p><ul><li>messageHandlers 字典，以 handlerName 作为 key，保存对应 function</li><li>responseCallbacks 字典，以 callbackId 作为 key，保存响应 function</li></ul><p><strong>function</strong></p><ul><li>doSend: 调用另一端方法，传递 message 字典参数</li><li>responseAnotherMethod: 响应另一端的调用，接收 message 字典参数</li></ul><h2 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h2><p>Manager 为整个 Hybrid 核心，负责 JS 方法到 Native 端的映射，可灵活扩展。利用 runtime 特性，使用得到的 className 和 functionName 反射出指定的对象，并执行指定函数。</p><h2 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h2><p>针对打开的 WebView, 是否拥有合法使用 Hybrid 的权限需要进行验证，只有验证通过的页面，才能使用原生提供的能力。Manager 提供入口，具体验证由上层实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)authenticationSignatureParameter:(NSDictionary *)parameter comlete:(void (^)(NSError *error))complete;</span><br></pre></td></tr></table></figure><h2 id="组件协议"><a href="#组件协议" class="headerlink" title="组件协议"></a>组件协议</h2><p>JS 页面加载完，在使用 Native 能力之前，需要进行注册，即告知 Native 当前页面所需要使用的 API 列表。Manager 处理该流程，验证 Native 是否实现该 API，同时把 API 转换成对象，对象遵循以下协议：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@protocol KKWebViewJSApiBaseProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@required</span><br><span class="line">/// api名字</span><br><span class="line">@property (nonatomic, copy) NSString *apiName;</span><br><span class="line">/// 是否支持js多次回调</span><br><span class="line">@property (nonatomic, assign) NSInteger isNeedRegistId;</span><br><span class="line">/// 是否为事件类型，客户端调用，类似发通知给JS</span><br><span class="line">@property (nonatomic, assign) NSInteger isEvent;</span><br><span class="line">/// api接口参数数据</span><br><span class="line">@property (nonatomic, strong) NSDictionary *paramData;</span><br><span class="line">/// api接口响应回调</span><br><span class="line">@property (nonatomic, copy) WVJBResponseCallback responseCallback;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) KKWebViewJavaScriptManager *jsManager;</span><br><span class="line"></span><br><span class="line">@end;</span><br></pre></td></tr></table></figure><h2 id="反射函数"><a href="#反射函数" class="headerlink" title="反射函数"></a>反射函数</h2><p>Manager 把 API 转换成对象时，利用 Objective-C 的 runtime 反射机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class cls = NSClassFromString(className);</span><br><span class="line">if ([cls conformsToProtocol:@protocol(KKWebViewJSApiBaseProtocol)]) &#123;</span><br><span class="line">    id&lt;KKWebViewJSApiBaseProtocol&gt; obj = [[cls alloc] init];</span><br><span class="line">    if ([obj respondsToSelector:NSSelectorFromString(functionName)]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">        [obj performSelector:NSSelectorFromString(functionName)];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        return obj;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;function is not found&quot;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;clss is not found&quot;);</span><br><span class="line">     return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://awhisper.github.io/2018/01/02/hybrid-jscomunication" target="_blank" rel="noopener">从零收拾一个hybrid框架</a></p><p><a href="https://juejin.im/post/5abca877f265da238155b6bc" target="_blank" rel="noopener">JSBridge 的原理</a></p><p><a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="noopener">WKWebView 那些坑</a></p><p><a href="https://www.cnblogs.com/yexiaochai/p/4921635.html" target="_blank" rel="noopener">浅谈 Hybrid 技术的设计与实现</a><br><a href="https://blog.csdn.net/byeweiyang/article/details/75102051" target="_blank" rel="noopener"><br>58 同城 iOS 客户端 Hybrid 框架探索</a></p><p><a href="https://lvwenhan.com/ios/460.html" target="_blank" rel="noopener">自己动手打造基于 WKWebView 的混合开发框架</a></p>]]></content>
      
      
      <categories>
          
          <category> Hybird </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>织语 IM 消息 框架设计</title>
      <link href="/2018/03/02/%E7%BB%87%E8%AF%AD-IM-%E6%B6%88%E6%81%AF-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/03/02/%E7%BB%87%E8%AF%AD-IM-%E6%B6%88%E6%81%AF-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如何从零开始设计消息界面，应该考虑哪些问题。<br>架构的选型，消息页面承载了各种各样的业务，不应该所有业务都集中在 VC，随着业务的增长，VC 只会越来越臃肿，合适的架构，不仅便于拓展，也有利于消息页面的长足发展。</p><p>消息页面业务列表：</p><ul><li>消息接收，发送，更新</li><li>消息的上下加载</li><li>不同消息 cell 展示</li><li>cell 长按 menu 事件</li><li>cell 内点击事件</li><li>输入框事件</li><li>不同消息页的展示</li></ul><h2 id="消息界面框架"><a href="#消息界面框架" class="headerlink" title="消息界面框架"></a>消息界面框架</h2><p>消息界面 MessageViewController 继承 UIViewController，由 UITableView(界面)，MessageConfig (消息配置)，MessageInteractor (逻辑控制器) 作为基本构成。</p><h3 id="消息配置类"><a href="#消息配置类" class="headerlink" title="消息配置类"></a>消息配置类</h3><p>APP 内会存在不同消息界面展示需求，如单聊，群聊，公众号，历史消息浏览等，框架抽象出一些常用的配置接口以便于业务方修改界面。配置类不是必须实现的，如果不实现，则使用默认配置。</p><p>配置类具体注入步骤为:</p><ul><li>继承消息类 MessageViewController 。</li><li>创建配置类，实现协议 MessageConfig。</li><li>在继承的消息类中，重写父类接口 - (id<messageconfig>)messageConfig 方法，返回创建的配置类。</messageconfig></li></ul><h3 id="逻辑实现类"><a href="#逻辑实现类" class="headerlink" title="逻辑实现类"></a>逻辑实现类</h3><p>由于消息界面比较复杂，框架抽象出了逻辑实现类接口 MessageInteractor<br>MessageInteractor 由 数据逻辑 MessageDataSource 和 排版逻辑 MessageLayout 两部分接口组成。</p><p>数据逻辑 MessageDataSource 主要用于消息的数据的增删改查，作为界面的数据源，并缓存一些计算的中间数据，避免重复运算，提高性能。</p><p>排版逻辑 MessageLayout 主要用于消息的排版操作， MessageLayout 不关心具体数据，只根据上层控制，对界面排版做出调整。</p><h2 id="消息展示逻辑"><a href="#消息展示逻辑" class="headerlink" title="消息展示逻辑"></a>消息展示逻辑</h2><h3 id="消息普通展示"><a href="#消息普通展示" class="headerlink" title="消息普通展示"></a>消息普通展示</h3><ul><li>消息通过 srvMsgId 和 clientOrder 两者共同排序。srvMsgId，为服务器生成的消息有序 Id。clientOrder 为本地客户端生成的有序数列。消息排序时，先根据 srvMsgId 进行排序，如果srvMsgId 一致，则在比较 clientOrder。正常情况下，发送成功的消息，即拥有唯一 srvMsgId。但客户端新建一条待发送的消息时，该消息的 srvMsgId，取至本地消息最大的 srvMsgId，同时 clientOrder 在最大消息的 clientOrder 上加一。这样子保证了本地消息排序的有序。等到新消息发送成功，服务器返回后，更新该 srvMsgId 为服务器的最新 srvMsgId，同时 clientOrder 置为0。</li></ul><blockquote><p>消息发送成功后，返回 srvMsgId 可能导致排序变化，出于性能考量，不对已展示消息重新排序，等用户下次再进入消息界面，即会展示正确的消息排序。</p></blockquote><ul><li>上拉拉取数据逻辑，异步加载一屏本地数据，如果本地数据不足一屏，则再异步拉取服务器数据。凑满一屏数据后，返回界面展示。当服务器返回无更多数据后，上拉拉取UI控件隐藏</li><li>一直加载老数据，使得数据源消息数大于设定的最大值时，则清楚数据源内排序靠后的老数据，同时向下加载更多 UI 控件变更为显示</li></ul><blockquote><p>上拉拉取时，菊花开始转，tableView 处于滑动状态，offset 一直在变。应该等 tableVew 停止滑动后，再开始进行 tableView 的 reloadData 操作，重设 offset。所以调用 performSelectorOnMainThread:withObject:waitUntilDone:modes: 执行 reloadData 操作，该方法能在 tableView 停止滑动，即 runloop 空闲后执行操作。</p></blockquote><ul><li><p>下拉加载数据逻辑，仅当向下加载更多UI控件显示时，触发。逻辑同上拉拉取逻辑一致。当服务器返回无更多数据后，向下加载更多UI控件隐藏。</p></li><li><p>点击输入框时，界面直接跳转至最新数据展示。以向下加载更多UI控件是否隐藏作为标志位，如果隐藏，说明当前数据即为最新数据，界面直接跳转至末尾。如果显示，则当前数据不是最新数据，则清空界面数据，异步拉取最新一屏本地数据展示，同时异步拉取服务器最新数据，待服务器数据返回后，再和本地数据合并，展示在界面。</p></li><li><p>接收新消息时，后台线程计算Layout，计算完毕后，放入 pendingMessage 数组，在合适的时机，如 tableView 无滑动时，切主线程，一个一个的加入数据源，更新 tableView。如果数据源消息大于设定最大值，则清理数据源内排序靠前的老数据</p></li></ul><h3 id="正常进入消息界面"><a href="#正常进入消息界面" class="headerlink" title="正常进入消息界面"></a>正常进入消息界面</h3><ul><li>同步加载一屏本地数据，同时异步拉取服务器最新数据</li><li>服务器最新数据返回，如果与本地一致，不做处理。如果数据量大于一屏，清楚之前加载数据，替换数据为最新一屏数据。如果数据量小于一屏，则在展示的本地数据后，直接添加最新数据</li><li>向下加载更多UI控件隐藏</li></ul><h3 id="指定跳转某一条消息"><a href="#指定跳转某一条消息" class="headerlink" title="指定跳转某一条消息"></a>指定跳转某一条消息</h3><ul><li>以该条消息为基准，异步上下加载一屏本地数据，如果本地数据不足一屏，则再异步拉取服务器数据。凑满一屏数据后，返回界面展示</li><li>向下加载更多UI控件不隐藏</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 消息框架 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
